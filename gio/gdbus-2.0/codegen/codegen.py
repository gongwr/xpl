# -*- Mode: Python -*-
# coding=utf-8

# GDBus - GLib D-Bus Library
#
# Copyright (C) 2008-2018 Red Hat, Inc.
# Copyright (C) 2018 Iñigo Martínez <inigomartinez@gmail.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General
# Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
#
# Author: David Zeuthen <davidz@redhat.com>

from . import config
from . import utils
from . import dbustypes
from .utils import print_error

LICENSE_STR = """/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */\n"""


# Disable line length warnings as wrapping the C code templates would be hard
# flake8: noqa: E501


def generate_namespace(namespace):
    ns = namespace
    if len(namespace) > 0:
        if utils.is_ugly_case(namespace):
            ns = namespace.replace("_", "")
            ns_upper = namespace.upper() + "_"
            ns_lower = namespace.lower() + "_"
        else:
            ns_upper = utils.camel_case_to_uscore(namespace).upper() + "_"
            ns_lower = utils.camel_case_to_uscore(namespace).lower() + "_"
    else:
        ns_upper = ""
        ns_lower = ""

    return (ns, ns_upper, ns_lower)


def generate_header_guard(header_name):
    # There might be more characters that are safe to use than these, but lets
    # stay conservative.
    safe_valid_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    return "".join(
        map(lambda c: c if c in safe_valid_chars else "_", header_name.upper())
    )


class HeaderCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        generate_objmanager,
        generate_autocleanup,
        header_name,
        input_files_basenames,
        use_pragma,
        glib_min_required,
        symbol_decorator,
        symbol_decorator_header,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.generate_objmanager = generate_objmanager
        self.generate_autocleanup = generate_autocleanup
        self.header_guard = generate_header_guard(header_name)
        self.input_files_basenames = input_files_basenames
        self.use_pragma = use_pragma
        self.glib_min_required = glib_min_required
        self.symbol_decorator = symbol_decorator
        self.symbol_decorator_header = symbol_decorator_header
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_header_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        self.outfile.write("\n")

        if self.use_pragma:
            self.outfile.write("#pragma once\n")
        else:
            self.outfile.write("#ifndef __{!s}__\n".format(self.header_guard))
            self.outfile.write("#define __{!s}__\n".format(self.header_guard))

        if self.symbol_decorator_header is not None:
            self.outfile.write("\n")
            self.outfile.write('#include "%s"\n' % self.symbol_decorator_header)

        self.outfile.write("\n")
        self.outfile.write("#include <gio/gio.h>\n")
        self.outfile.write("\n")
        self.outfile.write("G_BEGIN_DECLS\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def declare_types(self):
        for i in self.ifaces:
            self.outfile.write("\n")
            self.outfile.write(
                "/* ------------------------------------------------------------------------ */\n"
            )
            self.outfile.write("/* Declarations for %s */\n" % i.name)
            self.outfile.write("\n")

            # First the GInterface
            self.outfile.write(
                "#define %sTYPE_%s (%s_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s, %s))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %s%s_GET_IFACE(o) (XTYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_%s, %sIface))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%s;\n" % (i.camel_name))
            self.outfile.write(
                "typedef struct _%s %s;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sIface %sIface;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sIface\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  xtype_interface_t parent_iface;\n")

            function_pointers = {}

            # vfuncs for methods
            if len(i.methods) > 0:
                self.outfile.write("\n")
                for m in i.methods:
                    key = (m.since, "_method_%s" % m.name_lower)
                    value = "  xboolean_t (*handle_%s) (\n" % (m.name_lower)
                    value += "    %s *object,\n" % (i.camel_name)
                    value += "    xdbus_method_invocation_t *invocation"
                    if m.unix_fd:
                        value += ",\n    xunix_fd_list_t *fd_list"
                    for a in m.in_args:
                        value += ",\n    %sarg_%s" % (a.ctype_in, a.name)
                    value += ");\n\n"
                    function_pointers[key] = value

            # vfuncs for signals
            if len(i.signals) > 0:
                self.outfile.write("\n")
                for s in i.signals:
                    key = (s.since, "_signal_%s" % s.name_lower)
                    value = "  void (*%s) (\n" % (s.name_lower)
                    value += "    %s *object" % (i.camel_name)
                    for a in s.args:
                        value += ",\n    %sarg_%s" % (a.ctype_in, a.name)
                    value += ");\n\n"
                    function_pointers[key] = value

            # vfuncs for properties
            if len(i.properties) > 0:
                self.outfile.write("\n")
                for p in i.properties:
                    key = (p.since, "_prop_get_%s" % p.name_lower)
                    value = "  %s (*get_%s) (%s *object);\n\n" % (
                        p.arg.ctype_in,
                        p.name_lower,
                        i.camel_name,
                    )
                    function_pointers[key] = value

            # Sort according to @since tag, then name.. this ensures
            # that the function pointers don't change order assuming
            # judicious use of @since
            #
            # Also use a proper version comparison function so e.g.
            # 10.0 comes after 2.0.
            #
            # See https://bugzilla.gnome.org/show_bug.cgi?id=647577#c5
            # for discussion
            for key in sorted(function_pointers.keys(), key=utils.version_cmp_key):
                self.outfile.write("%s" % function_pointers[key])

            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.generate_autocleanup == "all":
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%s, xobject_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %s_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xdbus_interface_info_t *%s_interface_info (void);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xuint_t %s_override_properties (xobject_class_t *klass, xuint_t property_id_begin);\n"
                % (i.name_lower)
            )
            self.outfile.write("\n")

            # Then method call completion functions
            if len(i.methods) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus method call completion functions: */\n")
                for m in i.methods:
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_complete_%s (\n"
                        "    %s *object,\n"
                        "    xdbus_method_invocation_t *invocation"
                        % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    if m.unix_fd:
                        self.outfile.write(",\n    xunix_fd_list_t *fd_list")
                    for a in m.out_args:
                        self.outfile.write(",\n    %s%s" % (a.ctype_in, a.name))
                    self.outfile.write(");\n")
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then signal emission functions
            if len(i.signals) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus signal emissions functions: */\n")
                for s in i.signals:
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if s.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_emit_%s (\n"
                        "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
                    )
                    for a in s.args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    self.outfile.write(");\n")
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then method call declarations
            if len(i.methods) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus method calls: */\n")
                for m in i.methods:
                    # async begin
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_call_%s (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.in_args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    if self.glib_min_required >= (2, 64):
                        self.outfile.write(
                            ",\n    GDBusCallFlags call_flags"
                            ",\n    xint_t timeout_msec"
                        )
                    if m.unix_fd:
                        self.outfile.write(",\n    xunix_fd_list_t *fd_list")
                    self.outfile.write(
                        ",\n"
                        "    xcancellable_t *cancellable,\n"
                        "    xasync_ready_callback_t callback,\n"
                        "    xpointer_t user_data);\n"
                    )
                    self.outfile.write("\n")
                    # async finish
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "xboolean_t %s_call_%s_finish (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.out_args:
                        self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
                    if m.unix_fd:
                        self.outfile.write(",\n    xunix_fd_list_t **out_fd_list")
                    self.outfile.write(
                        ",\n" "    xasync_result_t *res,\n" "    xerror_t **error);\n"
                    )
                    self.outfile.write("\n")
                    # sync
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "xboolean_t %s_call_%s_sync (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.in_args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    if self.glib_min_required >= (2, 64):
                        self.outfile.write(
                            ",\n    GDBusCallFlags call_flags"
                            ",\n    xint_t timeout_msec"
                        )
                    if m.unix_fd:
                        self.outfile.write(",\n    xunix_fd_list_t  *fd_list")
                    for a in m.out_args:
                        self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
                    if m.unix_fd:
                        self.outfile.write(",\n    xunix_fd_list_t **out_fd_list")
                    self.outfile.write(
                        ",\n"
                        "    xcancellable_t *cancellable,\n"
                        "    xerror_t **error);\n"
                    )
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then the property accessor declarations
            if len(i.properties) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus property accessors: */\n")
                for p in i.properties:
                    # getter
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if p.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "%s%s_get_%s (%s *object);\n"
                        % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
                    )
                    if p.arg.free_func is not None:
                        if self.symbol_decorator is not None:
                            self.outfile.write("%s\n" % self.symbol_decorator)
                        if p.deprecated:
                            self.outfile.write("G_GNUC_DEPRECATED ")
                        self.outfile.write(
                            "%s%s_dup_%s (%s *object);\n"
                            % (
                                p.arg.ctype_in_dup,
                                i.name_lower,
                                p.name_lower,
                                i.camel_name,
                            )
                        )
                    # setter
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if p.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_set_%s (%s *object, %svalue);\n"
                        % (i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in)
                    )
                    self.outfile.write("\n")

            # Then the proxy
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_%s_PROXY (%s_proxy_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s_PROXY(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_PROXY, %sProxy))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_PROXY_CLASS(k) (XTYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_PROXY, %sProxyClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_PROXY_GET_CLASS(o) (XTYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_PROXY, %sProxyClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s_PROXY(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_PROXY))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %sIS_%s_PROXY_CLASS(k) (XTYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_PROXY))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sProxy %sProxy;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sProxyClass %sProxyClass;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sProxyPrivate %sProxyPrivate;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sProxy\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  xdbus_proxy_t parent_instance;\n")
            self.outfile.write("  %sProxyPrivate *priv;\n" % (i.camel_name))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sProxyClass\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusProxyClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %s_proxy_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sProxy, xobject_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "void %s_proxy_new (\n"
                "    xdbus_connection_t     *connection,\n"
                "    xdbus_proxy_flags_t      flags,\n"
                "    const xchar_t         *name,\n"
                "    const xchar_t         *object_path,\n"
                "    xcancellable_t        *cancellable,\n"
                "    xasync_ready_callback_t  callback,\n"
                "    xpointer_t             user_data);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_finish (\n"
                "    xasync_result_t        *res,\n"
                "    xerror_t             **error);\n" % (i.camel_name, i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_sync (\n"
                "    xdbus_connection_t     *connection,\n"
                "    xdbus_proxy_flags_t      flags,\n"
                "    const xchar_t         *name,\n"
                "    const xchar_t         *object_path,\n"
                "    xcancellable_t        *cancellable,\n"
                "    xerror_t             **error);\n" % (i.camel_name, i.name_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "void %s_proxy_new_for_bus (\n"
                "    xbus_type_t             bus_type,\n"
                "    xdbus_proxy_flags_t      flags,\n"
                "    const xchar_t         *name,\n"
                "    const xchar_t         *object_path,\n"
                "    xcancellable_t        *cancellable,\n"
                "    xasync_ready_callback_t  callback,\n"
                "    xpointer_t             user_data);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_for_bus_finish (\n"
                "    xasync_result_t        *res,\n"
                "    xerror_t             **error);\n" % (i.camel_name, i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_for_bus_sync (\n"
                "    xbus_type_t             bus_type,\n"
                "    xdbus_proxy_flags_t      flags,\n"
                "    const xchar_t         *name,\n"
                "    const xchar_t         *object_path,\n"
                "    xcancellable_t        *cancellable,\n"
                "    xerror_t             **error);\n" % (i.camel_name, i.name_lower)
            )
            self.outfile.write("\n")

            # Then the skeleton
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_%s_SKELETON (%s_skeleton_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s_SKELETON(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_SKELETON, %sSkeleton))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_SKELETON_CLASS(k) (XTYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_SKELETON, %sSkeletonClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_SKELETON_GET_CLASS(o) (XTYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_SKELETON, %sSkeletonClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s_SKELETON(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_SKELETON))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %sIS_%s_SKELETON_CLASS(k) (XTYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_SKELETON))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sSkeleton %sSkeleton;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sSkeletonClass %sSkeletonClass;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sSkeletonPrivate %sSkeletonPrivate;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sSkeleton\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  xdbus_interface_skeleton_t parent_instance;\n")
            self.outfile.write("  %sSkeletonPrivate *priv;\n" % (i.camel_name))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sSkeletonClass\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusInterfaceSkeletonClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %s_skeleton_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sSkeleton, xobject_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_skeleton_new (void);\n" % (i.camel_name, i.name_lower)
            )

            self.outfile.write("\n")

        # Finally, the Object, ObjectProxy, ObjectSkeleton and ObjectManagerClient
        if self.generate_objmanager:
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT (%sobject_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT, %sObject))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sOBJECT_GET_IFACE(o) (XTYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_OBJECT, %sObject))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObject;\n" % (self.namespace))
            self.outfile.write(
                "typedef struct _%sObject %sObject;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectIface %sObjectIface;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectIface\n" % (self.namespace))
            self.outfile.write("{\n" "  xtype_interface_t parent_iface;\n" "};\n" "\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %sobject_get_type (void) G_GNUC_CONST;\n" "\n" % (self.ns_lower)
            )
            if self.generate_autocleanup == "all":
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObject, xobject_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "%s *%sobject_get_%s (%sObject *object);\n"
                    % (
                        i.camel_name,
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                    )
                )
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "%s *%sobject_peek_%s (%sObject *object);\n"
                    % (
                        i.camel_name,
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                    )
                )
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_PROXY (%sobject_proxy_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_PROXY, %sObjectProxy))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY_CLASS(k) (XTYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_PROXY, %sObjectProxyClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY_GET_CLASS(o) (XTYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_PROXY, %sObjectProxyClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_PROXY(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_PROXY))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_PROXY_CLASS(k) (XTYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_PROXY))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectProxy %sObjectProxy;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectProxyClass %sObjectProxyClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectProxyPrivate %sObjectProxyPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectProxy\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  xdbus_object_proxy_t parent_instance;\n")
            self.outfile.write("  %sObjectProxyPrivate *priv;\n" % (self.namespace))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectProxyClass\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  xdbus_object_proxy_class_t parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %sobject_proxy_get_type (void) G_GNUC_CONST;\n" % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectProxy, xobject_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "%sObjectProxy *%sobject_proxy_new (xdbus_connection_t *connection, const xchar_t *object_path);\n"
                % (self.namespace, self.ns_lower)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_SKELETON (%sobject_skeleton_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_SKELETON, %sObjectSkeleton))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON_CLASS(k) (XTYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_SKELETON, %sObjectSkeletonClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON_GET_CLASS(o) (XTYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_SKELETON, %sObjectSkeletonClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_SKELETON(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_SKELETON))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_SKELETON_CLASS(k) (XTYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_SKELETON))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectSkeleton %sObjectSkeleton;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectSkeletonClass %sObjectSkeletonClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectSkeletonPrivate %sObjectSkeletonPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectSkeleton\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  xdbus_object_skeleton_t parent_instance;\n")
            self.outfile.write("  %sObjectSkeletonPrivate *priv;\n" % (self.namespace))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectSkeletonClass\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusObjectSkeletonClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %sobject_skeleton_get_type (void) G_GNUC_CONST;\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectSkeleton, xobject_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "%sObjectSkeleton *%sobject_skeleton_new (const xchar_t *object_path);\n"
                % (self.namespace, self.ns_lower)
            )
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "void %sobject_skeleton_set_%s (%sObjectSkeleton *object, %s *interface_);\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                    )
                )
            self.outfile.write("\n")

            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_MANAGER_CLIENT (%sobject_manager_client_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT(o) (XTYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClient))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT_CLASS(k) (XTYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT_GET_CLASS(o) (XTYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_MANAGER_CLIENT(o) (XTYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_MANAGER_CLIENT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_MANAGER_CLIENT_CLASS(k) (XTYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_MANAGER_CLIENT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectManagerClient %sObjectManagerClient;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectManagerClientClass %sObjectManagerClientClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectManagerClientPrivate %sObjectManagerClientPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectManagerClient\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  xdbus_object_manager_client_t parent_instance;\n")
            self.outfile.write(
                "  %sObjectManagerClientPrivate *priv;\n" % (self.namespace)
            )
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write(
                "struct _%sObjectManagerClientClass\n" % (self.namespace)
            )
            self.outfile.write("{\n")
            self.outfile.write("  GDBusObjectManagerClientClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if XPL_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectManagerClient, xobject_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %sobject_manager_client_get_type (void) G_GNUC_CONST;\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xtype_t %sobject_manager_client_get_proxy_type (xdbus_object_manager_client_t *manager, const xchar_t *object_path, const xchar_t *interface_name, xpointer_t user_data);\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "void %sobject_manager_client_new (\n"
                "    xdbus_connection_t        *connection,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const xchar_t            *name,\n"
                "    const xchar_t            *object_path,\n"
                "    xcancellable_t           *cancellable,\n"
                "    xasync_ready_callback_t     callback,\n"
                "    xpointer_t                user_data);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xdbus_object_manager_t *%sobject_manager_client_new_finish (\n"
                "    xasync_result_t        *res,\n"
                "    xerror_t             **error);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xdbus_object_manager_t *%sobject_manager_client_new_sync (\n"
                "    xdbus_connection_t        *connection,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const xchar_t            *name,\n"
                "    const xchar_t            *object_path,\n"
                "    xcancellable_t           *cancellable,\n"
                "    xerror_t                **error);\n" % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "void %sobject_manager_client_new_for_bus (\n"
                "    xbus_type_t                bus_type,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const xchar_t            *name,\n"
                "    const xchar_t            *object_path,\n"
                "    xcancellable_t           *cancellable,\n"
                "    xasync_ready_callback_t     callback,\n"
                "    xpointer_t                user_data);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xdbus_object_manager_t *%sobject_manager_client_new_for_bus_finish (\n"
                "    xasync_result_t        *res,\n"
                "    xerror_t             **error);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "xdbus_object_manager_t *%sobject_manager_client_new_for_bus_sync (\n"
                "    xbus_type_t                bus_type,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const xchar_t            *name,\n"
                "    const xchar_t            *object_path,\n"
                "    xcancellable_t           *cancellable,\n"
                "    xerror_t                **error);\n" % (self.ns_lower)
            )
            self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_header_postamble(self):
        self.outfile.write("\n")
        self.outfile.write("G_END_DECLS\n")

        if not self.use_pragma:
            self.outfile.write("\n")
            self.outfile.write("#endif /* __{!s}__ */\n".format(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_header_preamble()
        self.declare_types()
        self.generate_header_postamble()


# ----------------------------------------------------------------------------------------------------


class InterfaceInfoHeaderCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        header_name,
        input_files_basenames,
        use_pragma,
        glib_min_required,
        symbol_decorator,
        symbol_decorator_header,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.header_guard = generate_header_guard(header_name)
        self.input_files_basenames = input_files_basenames
        self.use_pragma = use_pragma
        self.glib_min_required = glib_min_required
        self.symbol_decorator = symbol_decorator
        if self.symbol_decorator is None:
            self.symbol_decorator = ""
        self.symbol_decorator_header = symbol_decorator_header
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_header_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        self.outfile.write("\n")

        if self.use_pragma:
            self.outfile.write("#pragma once\n")
        else:
            self.outfile.write("#ifndef __{!s}__\n".format(self.header_guard))
            self.outfile.write("#define __{!s}__\n".format(self.header_guard))

        if self.symbol_decorator_header is not None:
            self.outfile.write("\n")
            self.outfile.write('#include "%s"\n' % self.symbol_decorator_header)

        self.outfile.write("\n")
        self.outfile.write("#include <gio/gio.h>\n")
        self.outfile.write("\n")
        self.outfile.write("G_BEGIN_DECLS\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def declare_infos(self):
        for i in self.ifaces:
            self.outfile.write(
                "extern %s const xdbus_interface_info_t %s_interface;\n"
                % (self.symbol_decorator, i.name_lower)
            )

    # ----------------------------------------------------------------------------------------------------

    def generate_header_postamble(self):
        self.outfile.write("\n")
        self.outfile.write("G_END_DECLS\n")

        if not self.use_pragma:
            self.outfile.write("\n")
            self.outfile.write("#endif /* __{!s}__ */\n".format(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_header_preamble()
        self.declare_infos()
        self.generate_header_postamble()


# ----------------------------------------------------------------------------------------------------


class InterfaceInfoBodyCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        header_name,
        input_files_basenames,
        glib_min_required,
        symbol_decoration_define,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.header_name = header_name
        self.input_files_basenames = input_files_basenames
        self.glib_min_required = glib_min_required
        self.symbol_decoration_define = symbol_decoration_define
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_body_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))

        if self.symbol_decoration_define is not None:
            self.outfile.write("\n")
            self.outfile.write("#define %s\n" % self.symbol_decoration_define)

        self.outfile.write("\n")
        self.outfile.write(
            "#ifdef HAVE_CONFIG_H\n"
            '#  include "config.h"\n'
            "#endif\n"
            "\n"
            '#include "%s"\n'
            "\n"
            "#include <string.h>\n" % (self.header_name)
        )
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_array(self, array_name_lower, element_type, elements):
        self.outfile.write(
            "const %s * const %s[] =\n" % (element_type, array_name_lower)
        )
        self.outfile.write("{\n")
        for (_, name) in elements:
            self.outfile.write("  &%s,\n" % name)
        self.outfile.write("  NULL,\n")
        self.outfile.write("};\n")
        self.outfile.write("\n")

    def define_annotations(self, array_name_lower, annotations):
        if len(annotations) == 0:
            return

        annotation_pointers = []

        for a in annotations:
            # Skip internal annotations.
            if a.key.startswith("org.gtk.GDBus"):
                continue

            self.define_annotations(
                "%s__%s_annotations" % (array_name_lower, a.key_lower), a.annotations
            )

            self.outfile.write(
                "const xdbus_annotation_info_t %s__%s_annotation =\n"
                % (array_name_lower, a.key_lower)
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (xchar_t *) "%s",\n' % a.key)
            self.outfile.write('  (xchar_t *) "%s",\n' % a.value)
            if len(a.annotations) > 0:
                self.outfile.write(
                    "  (xdbus_annotation_info_t **) %s__%s_annotations,\n"
                    % (array_name_lower, a.key_lower)
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

            key = (a.since, "%s__%s_annotation" % (array_name_lower, a.key_lower))
            annotation_pointers.append(key)

        self.generate_array(
            array_name_lower, "xdbus_annotation_info_t", annotation_pointers
        )

    def define_args(self, array_name_lower, args):
        if len(args) == 0:
            return

        arg_pointers = []

        for a in args:
            self.define_annotations(
                "%s__%s_arg_annotations" % (array_name_lower, a.name), a.annotations
            )

            self.outfile.write(
                "const xdbus_arg_info_t %s__%s_arg =\n" % (array_name_lower, a.name)
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (xchar_t *) "%s",\n' % a.name)
            self.outfile.write('  (xchar_t *) "%s",\n' % a.signature)
            if len(a.annotations) > 0:
                self.outfile.write(
                    "  (xdbus_annotation_info_t **) %s__%s_arg_annotations,\n"
                    % (array_name_lower, a.name)
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

            key = (a.since, "%s__%s_arg" % (array_name_lower, a.name))
            arg_pointers.append(key)

        self.generate_array(array_name_lower, "xdbus_arg_info_t", arg_pointers)

    def define_infos(self):
        for i in self.ifaces:
            self.outfile.write(
                "/* ------------------------------------------------------------------------ */\n"
            )
            self.outfile.write("/* Definitions for %s */\n" % i.name)
            self.outfile.write("\n")

            # GDBusMethodInfos.
            if len(i.methods) > 0:
                method_pointers = []

                for m in i.methods:
                    self.define_args(
                        "%s_interface__%s_method_in_args"
                        % (i.name_lower, m.name_lower),
                        m.in_args,
                    )
                    self.define_args(
                        "%s_interface__%s_method_out_args"
                        % (i.name_lower, m.name_lower),
                        m.out_args,
                    )
                    self.define_annotations(
                        "%s_interface__%s_method_annotations"
                        % (i.name_lower, m.name_lower),
                        m.annotations,
                    )

                    self.outfile.write(
                        "const xdbus_method_info_t %s_interface__%s_method =\n"
                        % (i.name_lower, m.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (xchar_t *) "%s",\n' % m.name)
                    if len(m.in_args) > 0:
                        self.outfile.write(
                            "  (xdbus_arg_info_t **) %s_interface__%s_method_in_args,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no in args */\n")
                    if len(m.out_args) > 0:
                        self.outfile.write(
                            "  (xdbus_arg_info_t **) %s_interface__%s_method_out_args,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no out args */\n")
                    if len(m.annotations) > 0:
                        self.outfile.write(
                            "  (xdbus_annotation_info_t **) %s_interface__%s_method_annotations,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        m.since,
                        "%s_interface__%s_method" % (i.name_lower, m.name_lower),
                    )
                    method_pointers.append(key)

                self.generate_array(
                    "%s_interface_methods" % i.name_lower,
                    "xdbus_method_info_t",
                    method_pointers,
                )

            # GDBusSignalInfos.
            if len(i.signals) > 0:
                signal_pointers = []

                for s in i.signals:
                    self.define_args(
                        "%s_interface__%s_signal_args" % (i.name_lower, s.name_lower),
                        s.args,
                    )
                    self.define_annotations(
                        "%s_interface__%s_signal_annotations"
                        % (i.name_lower, s.name_lower),
                        s.annotations,
                    )

                    self.outfile.write(
                        "const xdbus_signalInfo_t %s_interface__%s_signal =\n"
                        % (i.name_lower, s.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (xchar_t *) "%s",\n' % s.name)
                    if len(s.args) > 0:
                        self.outfile.write(
                            "  (xdbus_arg_info_t **) %s_interface__%s_signal_args,\n"
                            % (i.name_lower, s.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no args */\n")
                    if len(s.annotations) > 0:
                        self.outfile.write(
                            "  (xdbus_annotation_info_t **) %s_interface__%s_signal_annotations,\n"
                            % (i.name_lower, s.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        s.since,
                        "%s_interface__%s_signal" % (i.name_lower, s.name_lower),
                    )
                    signal_pointers.append(key)

                self.generate_array(
                    "%s_interface_signals" % i.name_lower,
                    "xdbus_signalInfo_t",
                    signal_pointers,
                )

            # GDBusPropertyInfos.
            if len(i.properties) > 0:
                property_pointers = []

                for p in i.properties:
                    if p.readable and p.writable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                    elif p.readable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE"
                    elif p.writable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                    else:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_NONE"

                    self.define_annotations(
                        "%s_interface__%s_property_annotations"
                        % (i.name_lower, p.name_lower),
                        p.annotations,
                    )

                    self.outfile.write(
                        "const xdbus_property_info_t %s_interface__%s_property =\n"
                        % (i.name_lower, p.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (xchar_t *) "%s",\n' % p.name)
                    self.outfile.write('  (xchar_t *) "%s",\n' % p.signature)
                    self.outfile.write("  %s,\n" % flags)
                    if len(p.annotations) > 0:
                        self.outfile.write(
                            "  (xdbus_annotation_info_t **) %s_interface__%s_property_annotations,\n"
                            % (i.name_lower, p.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        p.since,
                        "%s_interface__%s_property" % (i.name_lower, p.name_lower),
                    )
                    property_pointers.append(key)

                self.generate_array(
                    "%s_interface_properties" % i.name_lower,
                    "xdbus_property_info_t",
                    property_pointers,
                )

            # Finally the xdbus_interface_info_t.
            self.define_annotations(
                "%s_interface_annotations" % i.name_lower, i.annotations
            )

            self.outfile.write(
                "const xdbus_interface_info_t %s_interface =\n" % i.name_lower
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (xchar_t *) "%s",\n' % i.name)
            if len(i.methods) > 0:
                self.outfile.write(
                    "  (xdbus_method_info_t **) %s_interface_methods,\n" % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no methods */\n")
            if len(i.signals) > 0:
                self.outfile.write(
                    "  (xdbus_signalInfo_t **) %s_interface_signals,\n" % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no signals */\n")
            if len(i.properties) > 0:
                self.outfile.write(
                    "  (xdbus_property_info_t **) %s_interface_properties,\n" % i.name_lower
                )
            else:
                self.outfile.write("NULL,  /* no properties */\n")
            if len(i.annotations) > 0:
                self.outfile.write(
                    "  (xdbus_annotation_info_t **) %s_interface_annotations,\n"
                    % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_body_preamble()
        self.define_infos()


# ----------------------------------------------------------------------------------------------------


class CodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        generate_objmanager,
        header_name,
        input_files_basenames,
        docbook_gen,
        glib_min_required,
        symbol_decoration_define,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.generate_objmanager = generate_objmanager
        self.header_name = header_name
        self.input_files_basenames = input_files_basenames
        self.docbook_gen = docbook_gen
        self.glib_min_required = glib_min_required
        self.symbol_decoration_define = symbol_decoration_define
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_body_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        if self.symbol_decoration_define is not None:
            self.outfile.write("\n")
            self.outfile.write("#define %s\n" % self.symbol_decoration_define)
        self.outfile.write("\n")
        self.outfile.write(
            "#ifdef HAVE_CONFIG_H\n"
            '#  include "config.h"\n'
            "#endif\n"
            "\n"
            '#include "%s"\n'
            "\n"
            "#include <string.h>\n" % (self.header_name)
        )

        self.outfile.write(
            "#ifdef G_OS_UNIX\n" "#  include <gio/gunixfdlist.h>\n" "#endif\n" "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  xdbus_arg_info_t parent_struct;\n"
            "  xboolean_t use_gvariant;\n"
            "} _ExtendedGDBusArgInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  xdbus_method_info_t parent_struct;\n"
            "  const xchar_t *signal_name;\n"
            "  xboolean_t pass_fdlist;\n"
            "} _ExtendedGDBusMethodInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  xdbus_signalInfo_t parent_struct;\n"
            "  const xchar_t *signal_name;\n"
            "} _ExtendedGDBusSignalInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  xdbus_property_info_t parent_struct;\n"
            "  const xchar_t *hyphen_name;\n"
            "  xuint_t use_gvariant : 1;\n"
            "  xuint_t emits_changed_signal : 1;\n"
            "} _ExtendedGDBusPropertyInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  xdbus_interface_info_t parent_struct;\n"
            "  const xchar_t *hyphen_name;\n"
            "} _ExtendedGDBusInterfaceInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  const _ExtendedGDBusPropertyInfo *info;\n"
            "  xuint_t prop_id;\n"
            "  xvalue_t orixvalue; /* the value before the change */\n"
            "} ChangedProperty;\n"
            "\n"
            "static void\n"
            "_changed_property_free (ChangedProperty *data)\n"
            "{\n"
            "  xvalue_unset (&data->orixvalue);\n"
            "  g_free (data);\n"
            "}\n"
            "\n"
        )

        self.outfile.write(
            "static xboolean_t\n"
            "_xstrv_equal0 (xchar_t **a, xchar_t **b)\n"
            "{\n"
            "  xboolean_t ret = FALSE;\n"
            "  xuint_t n;\n"
            "  if (a == NULL && b == NULL)\n"
            "    {\n"
            "      ret = TRUE;\n"
            "      goto out;\n"
            "    }\n"
            "  if (a == NULL || b == NULL)\n"
            "    goto out;\n"
            "  if (xstrv_length (a) != xstrv_length (b))\n"
            "    goto out;\n"
            "  for (n = 0; a[n] != NULL; n++)\n"
            "    if (xstrcmp0 (a[n], b[n]) != 0)\n"
            "      goto out;\n"
            "  ret = TRUE;\n"
            "out:\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

        self.outfile.write(
            "static xboolean_t\n"
            "_xvariant_equal0 (xvariant_t *a, xvariant_t *b)\n"
            "{\n"
            "  xboolean_t ret = FALSE;\n"
            "  if (a == NULL && b == NULL)\n"
            "    {\n"
            "      ret = TRUE;\n"
            "      goto out;\n"
            "    }\n"
            "  if (a == NULL || b == NULL)\n"
            "    goto out;\n"
            "  ret = xvariant_equal (a, b);\n"
            "out:\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

        # simplified - only supports the types we use
        self.outfile.write(
            "G_GNUC_UNUSED static xboolean_t\n"
            "_xvalue_equal (const xvalue_t *a, const xvalue_t *b)\n"
            "{\n"
            "  xboolean_t ret = FALSE;\n"
            "  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));\n"
            "  switch (G_VALUE_TYPE (a))\n"
            "    {\n"
            "      case XTYPE_BOOLEAN:\n"
            "        ret = (xvalue_get_boolean (a) == xvalue_get_boolean (b));\n"
            "        break;\n"
            "      case XTYPE_UCHAR:\n"
            "        ret = (xvalue_get_uchar (a) == xvalue_get_uchar (b));\n"
            "        break;\n"
            "      case XTYPE_INT:\n"
            "        ret = (xvalue_get_int (a) == xvalue_get_int (b));\n"
            "        break;\n"
            "      case XTYPE_UINT:\n"
            "        ret = (xvalue_get_uint (a) == xvalue_get_uint (b));\n"
            "        break;\n"
            "      case XTYPE_INT64:\n"
            "        ret = (xvalue_get_int64 (a) == xvalue_get_int64 (b));\n"
            "        break;\n"
            "      case XTYPE_UINT64:\n"
            "        ret = (xvalue_get_uint64 (a) == xvalue_get_uint64 (b));\n"
            "        break;\n"
            "      case XTYPE_DOUBLE:\n"
            "        {\n"
            "          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */\n"
            "          xdouble_t da = xvalue_get_double (a);\n"
            "          xdouble_t db = xvalue_get_double (b);\n"
            "          ret = memcmp (&da, &db, sizeof (xdouble_t)) == 0;\n"
            "        }\n"
            "        break;\n"
            "      case XTYPE_STRING:\n"
            "        ret = (xstrcmp0 (xvalue_get_string (a), xvalue_get_string (b)) == 0);\n"
            "        break;\n"
            "      case XTYPE_VARIANT:\n"
            "        ret = _xvariant_equal0 (xvalue_get_variant (a), xvalue_get_variant (b));\n"
            "        break;\n"
            "      default:\n"
            "        if (G_VALUE_TYPE (a) == XTYPE_STRV)\n"
            "          ret = _xstrv_equal0 (xvalue_get_boxed (a), xvalue_get_boxed (b));\n"
            "        else\n"
            '          g_critical ("_xvalue_equal() does not handle type %s", xtype_name (G_VALUE_TYPE (a)));\n'
            "        break;\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

    def generate_annotations(self, prefix, annotations):
        if annotations is None:
            return

        n = 0
        for a in annotations:
            # self.generate_annotations('%s_%d'%(prefix, n), a.get_annotations())

            # skip internal annotations
            if a.key.startswith("org.gtk.GDBus"):
                continue

            self.outfile.write(
                "static const xdbus_annotation_info_t %s_%d =\n"
                "{\n"
                "  -1,\n"
                '  (xchar_t *) "%s",\n'
                '  (xchar_t *) "%s",\n' % (prefix, n, a.key, a.value)
            )
            if len(a.annotations) == 0:
                self.outfile.write("  NULL\n")
            else:
                self.outfile.write(
                    "  (xdbus_annotation_info_t **) &%s_%d_pointers\n" % (prefix, n)
                )
            self.outfile.write("};\n" "\n")
            n += 1

        if n > 0:
            self.outfile.write(
                "static const xdbus_annotation_info_t * const %s_pointers[] =\n"
                "{\n" % (prefix)
            )
            m = 0
            for a in annotations:
                if a.key.startswith("org.gtk.GDBus"):
                    continue
                self.outfile.write("  &%s_%d,\n" % (prefix, m))
                m += 1
            self.outfile.write("  NULL\n" "};\n" "\n")
        return n

    def generate_args(self, prefix, args):
        for a in args:
            num_anno = self.generate_annotations(
                "%s_arg_%s_annotation_info" % (prefix, a.name), a.annotations
            )

            self.outfile.write(
                "static const _ExtendedGDBusArgInfo %s_%s =\n"
                "{\n"
                "  {\n"
                "    -1,\n"
                '    (xchar_t *) "%s",\n'
                '    (xchar_t *) "%s",\n' % (prefix, a.name, a.name, a.signature)
            )
            if num_anno == 0:
                self.outfile.write("    NULL\n")
            else:
                self.outfile.write(
                    "    (xdbus_annotation_info_t **) &%s_arg_%s_annotation_info_pointers\n"
                    % (prefix, a.name)
                )
            self.outfile.write("  },\n")
            if not utils.lookup_annotation(
                a.annotations, "org.gtk.GDBus.C.ForceGVariant"
            ):
                self.outfile.write("  FALSE\n")
            else:
                self.outfile.write("  TRUE\n")
            self.outfile.write("};\n" "\n")

        if len(args) > 0:
            self.outfile.write(
                "static const xdbus_arg_info_t * const %s_pointers[] =\n" "{\n" % (prefix)
            )
            for a in args:
                self.outfile.write("  &%s_%s.parent_struct,\n" % (prefix, a.name))
            self.outfile.write("  NULL\n" "};\n" "\n")

    def generate_introspection_for_interface(self, i):
        self.outfile.write(
            "/* ---- Introspection data for %s ---- */\n" "\n" % (i.name)
        )

        if len(i.methods) > 0:
            for m in i.methods:
                self.generate_args(
                    "_%s_method_info_%s_IN_ARG" % (i.name_lower, m.name_lower),
                    m.in_args,
                )
                self.generate_args(
                    "_%s_method_info_%s_OUT_ARG" % (i.name_lower, m.name_lower),
                    m.out_args,
                )

                num_anno = self.generate_annotations(
                    "_%s_method_%s_annotation_info" % (i.name_lower, m.name_lower),
                    m.annotations,
                )

                self.outfile.write(
                    "static const _ExtendedGDBusMethodInfo _%s_method_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (xchar_t *) "%s",\n' % (i.name_lower, m.name_lower, m.name)
                )
                if len(m.in_args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (xdbus_arg_info_t **) &_%s_method_info_%s_IN_ARG_pointers,\n"
                        % (i.name_lower, m.name_lower)
                    )
                if len(m.out_args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (xdbus_arg_info_t **) &_%s_method_info_%s_OUT_ARG_pointers,\n"
                        % (i.name_lower, m.name_lower)
                    )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (xdbus_annotation_info_t **) &_%s_method_%s_annotation_info_pointers\n"
                        % (i.name_lower, m.name_lower)
                    )
                self.outfile.write(
                    "  },\n"
                    '  "handle-%s",\n'
                    "  %s\n" % (m.name_hyphen, "TRUE" if m.unix_fd else "FALSE")
                )
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const xdbus_method_info_t * const _%s_method_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for m in i.methods:
                self.outfile.write(
                    "  &_%s_method_info_%s.parent_struct,\n"
                    % (i.name_lower, m.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        # ---

        if len(i.signals) > 0:
            for s in i.signals:
                self.generate_args(
                    "_%s_signal_info_%s_ARG" % (i.name_lower, s.name_lower), s.args
                )

                num_anno = self.generate_annotations(
                    "_%s_signal_%s_annotation_info" % (i.name_lower, s.name_lower),
                    s.annotations,
                )
                self.outfile.write(
                    "static const _ExtendedGDBusSignalInfo _%s_signal_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (xchar_t *) "%s",\n' % (i.name_lower, s.name_lower, s.name)
                )
                if len(s.args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (xdbus_arg_info_t **) &_%s_signal_info_%s_ARG_pointers,\n"
                        % (i.name_lower, s.name_lower)
                    )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (xdbus_annotation_info_t **) &_%s_signal_%s_annotation_info_pointers\n"
                        % (i.name_lower, s.name_lower)
                    )
                self.outfile.write("  },\n" '  "%s"\n' % (s.name_hyphen))
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const xdbus_signalInfo_t * const _%s_signal_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for s in i.signals:
                self.outfile.write(
                    "  &_%s_signal_info_%s.parent_struct,\n"
                    % (i.name_lower, s.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        # ---

        if len(i.properties) > 0:
            for p in i.properties:
                if p.readable and p.writable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                elif p.readable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE"
                elif p.writable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                else:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_NONE"
                num_anno = self.generate_annotations(
                    "_%s_property_%s_annotation_info" % (i.name_lower, p.name_lower),
                    p.annotations,
                )
                self.outfile.write(
                    "static const _ExtendedGDBusPropertyInfo _%s_property_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (xchar_t *) "%s",\n'
                    '    (xchar_t *) "%s",\n'
                    "    %s,\n"
                    % (i.name_lower, p.name_lower, p.name, p.arg.signature, access)
                )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (xdbus_annotation_info_t **) &_%s_property_%s_annotation_info_pointers\n"
                        % (i.name_lower, p.name_lower)
                    )
                self.outfile.write("  },\n" '  "%s",\n' % (p.name_hyphen))
                if not utils.lookup_annotation(
                    p.annotations, "org.gtk.GDBus.C.ForceGVariant"
                ):
                    self.outfile.write("  FALSE,\n")
                else:
                    self.outfile.write("  TRUE,\n")
                if p.emits_changed_signal:
                    self.outfile.write("  TRUE\n")
                else:
                    self.outfile.write("  FALSE\n")
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const xdbus_property_info_t * const _%s_property_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for p in i.properties:
                self.outfile.write(
                    "  &_%s_property_info_%s.parent_struct,\n"
                    % (i.name_lower, p.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        num_anno = self.generate_annotations(
            "_%s_annotation_info" % (i.name_lower), i.annotations
        )
        self.outfile.write(
            "static const _ExtendedGDBusInterfaceInfo _%s_interface_info =\n"
            "{\n"
            "  {\n"
            "    -1,\n"
            '    (xchar_t *) "%s",\n' % (i.name_lower, i.name)
        )
        if len(i.methods) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (xdbus_method_info_t **) &_%s_method_info_pointers,\n" % (i.name_lower)
            )
        if len(i.signals) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (xdbus_signalInfo_t **) &_%s_signal_info_pointers,\n" % (i.name_lower)
            )
        if len(i.properties) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (xdbus_property_info_t **) &_%s_property_info_pointers,\n"
                % (i.name_lower)
            )
        if num_anno == 0:
            self.outfile.write("    NULL\n")
        else:
            self.outfile.write(
                "    (xdbus_annotation_info_t **) &_%s_annotation_info_pointers\n"
                % (i.name_lower)
            )
        self.outfile.write("  },\n" '  "%s",\n' "};\n" "\n" % (i.name_hyphen))
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_interface_info:\n"
                " *\n"
                " * Gets a machine-readable description of the #%s D-Bus interface.\n"
                " *\n"
                " * Returns: (transfer none): A #xdbus_interface_info_t. Do not free.\n"
                % (i.name_lower, i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "xdbus_interface_info_t *\n"
            "%s_interface_info (void)\n"
            "{\n"
            "  return (xdbus_interface_info_t *) &_%s_interface_info.parent_struct;\n"
            "}\n"
            "\n" % (i.name_lower, i.name_lower)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_override_properties:\n"
                " * @klass: The class structure for a #xobject_t derived class.\n"
                " * @property_id_begin: The property id to assign to the first overridden property.\n"
                " *\n"
                " * Overrides all #xobject_t properties in the #%s interface for a concrete class.\n"
                " * The properties are overridden in the order they are defined.\n"
                " *\n"
                " * Returns: The last property id.\n" % (i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "xuint_t\n" "%s_override_properties (xobject_class_t *klass" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED")
        self.outfile.write(", xuint_t property_id_begin)\n" "{\n")
        for p in i.properties:
            self.outfile.write(
                '  xobject_class_override_property (klass, property_id_begin++, "%s");\n'
                % (p.name_hyphen)
            )
        self.outfile.write("  return property_id_begin - 1;\n" "}\n" "\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_interface(self, i):
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s:\n"
                " *\n"
                " * Abstract interface type for the D-Bus interface #%s.\n"
                % (i.camel_name, i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sIface:\n"
                " * @parent_iface: The parent interface.\n" % (i.camel_name),
                False,
            )
        )

        doc_bits = {}
        if len(i.methods) > 0:
            for m in i.methods:
                key = (m.since, "_method_%s" % m.name_lower)
                value = "@handle_%s: " % (m.name_lower)
                value += "Handler for the #%s::handle-%s signal." % (
                    i.camel_name,
                    m.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.signals) > 0:
            for s in i.signals:
                key = (s.since, "_signal_%s" % s.name_lower)
                value = "@%s: " % (s.name_lower)
                value += "Handler for the #%s::%s signal." % (
                    i.camel_name,
                    s.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.properties) > 0:
            for p in i.properties:
                key = (p.since, "_prop_get_%s" % p.name_lower)
                value = "@get_%s: " % (p.name_lower)
                value += "Getter for the #%s:%s property." % (
                    i.camel_name,
                    p.name_hyphen,
                )
                doc_bits[key] = value
        for key in sorted(doc_bits.keys(), key=utils.version_cmp_key):
            self.outfile.write(" * %s\n" % doc_bits[key])

        self.outfile.write(
            self.docbook_gen.expand(
                " *\n" " * Virtual table for the D-Bus interface #%s.\n" % (i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sIface %sInterface;\n" % (i.camel_name, i.camel_name)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE (%s, %s, XTYPE_OBJECT)\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write("\n")

        self.outfile.write(
            "static void\n"
            "%s_default_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.methods) == 0 and len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.methods) > 0:
            self.outfile.write(
                "  /* xobject_t signals for incoming D-Bus method calls: */\n"
            )
            for m in i.methods:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::handle-%s:\n"
                        "   * @object: A #%s.\n"
                        "   * @invocation: A #xdbus_method_invocation_t.\n"
                        % (i.camel_name, m.name_hyphen, i.camel_name),
                        False,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(
                        "   * @fd_list: (nullable): A #xunix_fd_list_t or %NULL.\n"
                    )
                for a in m.in_args:
                    self.outfile.write(
                        "   * @arg_%s: Argument passed by remote caller.\n" % (a.name)
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * Signal emitted when a remote caller is invoking the %s.%s() D-Bus method.\n"
                        "   *\n"
                        "   * If a signal handler returns %%TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call %s_complete_%s() or e.g. xdbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %%G_DBUS_ERROR_UNKNOWN_METHOD error is returned.\n"
                        "   *\n"
                        "   * Returns: %%G_DBUS_METHOD_INVOCATION_HANDLED or %%TRUE if the invocation was handled, %%G_DBUS_METHOD_INVOCATION_UNHANDLED or %%FALSE to let other signal handlers run.\n"
                        % (i.name, m.name, i.name_lower, m.name_lower),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 2)
                if m.unix_fd:
                    extra_args = 2
                else:
                    extra_args = 1
                self.outfile.write(
                    '  xsignal_new ("handle-%s",\n'
                    "    XTYPE_FROM_INTERFACE (iface),\n"
                    "    G_SIGNAL_RUN_LAST,\n"
                    "    G_STRUCT_OFFSET (%sIface, handle_%s),\n"
                    "    xsignal_accumulator_true_handled,\n"
                    "    NULL,\n"  # accu_data
                    "    g_cclosure_marshal_generic,\n"
                    "    XTYPE_BOOLEAN,\n"
                    "    %d,\n"
                    "    XTYPE_DBUS_METHOD_INVOCATION"
                    % (
                        m.name_hyphen,
                        i.camel_name,
                        m.name_lower,
                        len(m.in_args) + extra_args,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(", XTYPE_UNIX_FD_LIST")
                for a in m.in_args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.signals) > 0:
            self.outfile.write("  /* xobject_t signals for received D-Bus signals: */\n")
            for s in i.signals:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::%s:\n"
                        "   * @object: A #%s.\n"
                        % (i.camel_name, s.name_hyphen, i.camel_name),
                        False,
                    )
                )
                for a in s.args:
                    self.outfile.write("   * @arg_%s: Argument.\n" % (a.name))
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * On the client-side, this signal is emitted whenever the D-Bus signal #%s::%s is received.\n"
                        "   *\n"
                        "   * On the service-side, this signal can be used with e.g. xsignal_emit_by_name() to make the object emit the D-Bus signal.\n"
                        % (i.name, s.name),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 2)
                self.outfile.write(
                    '  xsignal_new ("%s",\n'
                    "    XTYPE_FROM_INTERFACE (iface),\n"
                    "    G_SIGNAL_RUN_LAST,\n"
                    "    G_STRUCT_OFFSET (%sIface, %s),\n"
                    "    NULL,\n"  # accumulator
                    "    NULL,\n"  # accu_data
                    "    g_cclosure_marshal_generic,\n"
                    "    XTYPE_NONE,\n"
                    "    %d" % (s.name_hyphen, i.camel_name, s.name_lower, len(s.args))
                )
                for a in s.args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.properties) > 0:
            self.outfile.write("  /* xobject_t properties for D-Bus properties: */\n")
            for p in i.properties:
                if p.readable and p.writable:
                    hint = "Since the D-Bus property for this #xobject_t property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side."
                elif p.readable:
                    hint = "Since the D-Bus property for this #xobject_t property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side."
                elif p.writable:
                    hint = "Since the D-Bus property for this #xobject_t property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side."
                else:
                    print_error(
                        'Cannot handle property "{}" that neither readable nor writable'.format(
                            p.name
                        )
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s:%s:\n"
                        "   *\n"
                        "   * Represents the D-Bus property #%s:%s.\n"
                        "   *\n"
                        "   * %s\n"
                        % (i.camel_name, p.name_hyphen, i.name, p.name, hint),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 2)
                self.outfile.write("  xobject_interface_install_property (iface,\n")
                if p.arg.gtype == "XTYPE_VARIANT":
                    s = (
                        'g_param_spec_variant ("%s", "%s", "%s", G_VARIANT_TYPE ("%s"), NULL'
                        % (p.name_hyphen, p.name, p.name, p.arg.signature)
                    )
                elif p.arg.signature == "b":
                    s = 'g_param_spec_boolean ("%s", "%s", "%s", FALSE' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "y":
                    s = 'g_param_spec_uchar ("%s", "%s", "%s", 0, 255, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "n":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT16, G_MAXINT16, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "q":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT16, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "i":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT32, G_MAXINT32, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "u":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT32, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "x":
                    s = (
                        'g_param_spec_int64 ("%s", "%s", "%s", G_MININT64, G_MAXINT64, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "t":
                    s = 'g_param_spec_uint64 ("%s", "%s", "%s", 0, G_MAXUINT64, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "d":
                    s = (
                        'g_param_spec_double ("%s", "%s", "%s", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "s":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "o":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "g":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ay":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "as":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", XTYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ao":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", XTYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "aay":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", XTYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                else:
                    print_error(
                        'Unsupported gtype "{}" for xparam_spec_t'.format(p.arg.gtype)
                    )
                flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
                if p.deprecated:
                    flags = "G_PARAM_DEPRECATED | " + flags
                self.outfile.write("    %s, %s));" % (s, flags))
                self.outfile.write("\n")

        self.outfile.write("}\n" "\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_property_accessors(self, i):
        for p in i.properties:
            # getter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side."
            elif p.writable:
                hint = "Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_get_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " *\n"
                    " * Gets the value of the #%s:%s D-Bus property.\n"
                    " *\n"
                    " * %s\n"
                    " *\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            if p.arg.free_func is not None:
                self.outfile.write(
                    " * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use %s_dup_%s() if on another thread.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): The property value or %%NULL if the property is not set. Do not free the returned value, it belongs to @object.\n"
                    % (i.name_lower, p.name_lower)
                )
            else:
                self.outfile.write(" * Returns: The property value.\n")
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "%s\n"
                "%s_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  return %s%s_GET_IFACE (object)->get_%s (object);\n"
                % (i.ns_upper, i.name_upper, p.name_lower)
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")
            if p.arg.free_func is not None:

                self.outfile.write(
                    self.docbook_gen.expand(
                        "/**\n"
                        " * %s_dup_%s: (skip)\n"
                        " * @object: A #%s.\n"
                        " *\n"
                        " * Gets a copy of the #%s:%s D-Bus property.\n"
                        " *\n"
                        " * %s\n"
                        " *\n"
                        " * Returns: (transfer full) (nullable): The property value or %%NULL if the property is not set. The returned value should be freed with %s().\n"
                        % (
                            i.name_lower,
                            p.name_lower,
                            i.camel_name,
                            i.name,
                            p.name,
                            hint,
                            p.arg.free_func,
                        ),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
                self.outfile.write(
                    "%s\n"
                    "%s_dup_%s (%s *object)\n"
                    "{\n"
                    "  %svalue;\n"
                    % (
                        p.arg.ctype_in_dup,
                        i.name_lower,
                        p.name_lower,
                        i.camel_name,
                        p.arg.ctype_in_dup,
                    )
                )
                self.outfile.write(
                    '  xobject_get (G_OBJECT (object), "%s", &value, NULL);\n'
                    % (p.name_hyphen)
                )
                self.outfile.write("  return value;\n")
                self.outfile.write("}\n")
                self.outfile.write("\n")

            # setter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side."
            elif p.writable:
                hint = "Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_set_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " * @value: The value to set.\n"
                    " *\n"
                    " * Sets the #%s:%s D-Bus property to @value.\n"
                    " *\n"
                    " * %s\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_set_%s (%s *object, %svalue)\n"
                "{\n" % (i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in)
            )
            self.outfile.write(
                '  xobject_set (G_OBJECT (object), "%s", value, NULL);\n'
                % (p.name_hyphen)
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_signal_emitters(self, i):
        for s in i.signals:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_emit_%s:\n"
                    " * @object: A #%s.\n" % (i.name_lower, s.name_lower, i.camel_name),
                    False,
                )
            )
            for a in s.args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the signal.\n" % (a.name)
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n" " * Emits the #%s::%s D-Bus signal.\n" % (i.name, s.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_emit_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n" "{\n" '  xsignal_emit_by_name (object, "%s"' % (s.name_hyphen)
            )
            for a in s.args:
                self.outfile.write(", arg_%s" % a.name)
            self.outfile.write(");\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_method_calls(self, i):
        for m in i.methods:
            # async begin
            self.outfile.write(
                "/**\n"
                " * %s_call_%s:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #xunix_fd_list_t or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                    " * @callback: A #xasync_ready_callback_t to call when the request is satisfied or %%NULL.\n"
                    " * @user_data: User data to pass to @callback.\n"
                    " *\n"
                    " * Asynchronously invokes the %s.%s() D-Bus method on @proxy.\n"
                    " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see xmain_context_push_thread_default()).\n"
                    " * You can then call %s_call_%s_finish() to get the result of the operation.\n"
                    " *\n"
                    " * See %s_call_%s_sync() for the synchronous, blocking version of this method.\n"
                    % (
                        i.name,
                        m.name,
                        i.name_lower,
                        m.name_lower,
                        i.name_lower,
                        m.name_lower,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_call_%s (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    xint_t timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    xunix_fd_list_t *fd_list")
            self.outfile.write(
                ",\n"
                "    xcancellable_t *cancellable,\n"
                "    xasync_ready_callback_t callback,\n"
                "    xpointer_t user_data)\n"
                "{\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  xdbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write("  xdbus_proxy_call (G_DBUS_PROXY (proxy),\n")
            self.outfile.write('    "%s",\n' '    xvariant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n")
            self.outfile.write(
                "    cancellable,\n" "    callback,\n" "    user_data);\n"
            )
            self.outfile.write("}\n" "\n")
            # async finish
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_finish:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out) (optional): Return location for a #xunix_fd_list_t or %NULL to ignore.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @res: The #xasync_result_t obtained from the #xasync_ready_callback_t passed to %s_call_%s().\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Finishes an operation started with %s_call_%s().\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name_lower, m.name_lower, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "xboolean_t\n"
                "%s_call_%s_finish (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    xunix_fd_list_t **out_fd_list")
            self.outfile.write(
                ",\n"
                "    xasync_result_t *res,\n"
                "    xerror_t **error)\n"
                "{\n"
                "  xvariant_t *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = xdbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);\n"
                )
            else:
                self.outfile.write(
                    "  _ret = xdbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);\n"
                )
            self.outfile.write("  if (_ret == NULL)\n" "    goto _out;\n")
            self.outfile.write("  xvariant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  xvariant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

            # sync
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_sync:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #xunix_fd_list_t or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out): Return location for a #xunix_fd_list_t or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Synchronously invokes the %s.%s() D-Bus method on @proxy. The calling thread is blocked until a reply is received.\n"
                    " *\n"
                    " * See %s_call_%s() for the asynchronous version of this method.\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name, m.name, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "xboolean_t\n"
                "%s_call_%s_sync (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    xint_t timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    xunix_fd_list_t  *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    xunix_fd_list_t **out_fd_list")
            self.outfile.write(
                ",\n"
                "    xcancellable_t *cancellable,\n"
                "    xerror_t **error)\n"
                "{\n"
                "  xvariant_t *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = xdbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write(
                    "  _ret = xdbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n"
                )
            self.outfile.write('    "%s",\n' '    xvariant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n" "    out_fd_list,\n")
            self.outfile.write(
                "    cancellable,\n"
                "    error);\n"
                "  if (_ret == NULL)\n"
                "    goto _out;\n"
            )
            self.outfile.write("  xvariant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  xvariant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_method_completers(self, i):
        for m in i.methods:
            self.outfile.write(
                "/**\n"
                " * %s_complete_%s:\n"
                " * @object: A #%s.\n"
                " * @invocation: (transfer full): A #xdbus_method_invocation_t.\n"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #xunix_fd_list_t or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(" * @%s: Parameter to return.\n" % (a.name))
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n"
                    " * Helper function used in service implementations to finish handling invocations of the %s.%s() D-Bus method. If you instead want to finish handling an invocation by returning an error, use xdbus_method_invocation_return_error() or similar.\n"
                    " *\n"
                    " * This method will free @invocation, you cannot use it afterwards.\n"
                    % (i.name, m.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_complete_%s (\n"
                "    %s *object G_GNUC_UNUSED,\n"
                "    xdbus_method_invocation_t *invocation"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(",\n    xunix_fd_list_t *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %s%s" % (a.ctype_in, a.name))
            self.outfile.write(")\n" "{\n")

            if m.unix_fd:
                self.outfile.write(
                    "  xdbus_method_invocation_return_value_with_unix_fd_list (invocation,\n"
                    '    xvariant_new ("('
                )
            else:
                self.outfile.write(
                    "  xdbus_method_invocation_return_value (invocation,\n"
                    '    xvariant_new ("('
                )
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                   %s" % (a.name))
            if m.unix_fd:
                self.outfile.write("),\n    fd_list);\n")
            else:
                self.outfile.write("));\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_proxy(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxy:\n"
                " *\n"
                " * The #%sProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sProxy.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sProxyPrivate\n"
            "{\n"
            "  GData *qdata;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void %s_proxy_iface_init (%sIface *iface);\n"
            "\n" % (i.name_lower, i.camel_name)
        )
        self.outfile.write("#if XPL_VERSION_MAX_ALLOWED >= XPL_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, XTYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sProxy)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, XTYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_proxy_finalize (xobject_t *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write("  g_datalist_clear (&proxy->priv->qdata);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_proxy_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors
        #
        # Note that we are guaranteed that prop_id starts at 1 and is
        # laid out in the same order as introspection data pointers
        #
        self.outfile.write(
            "static void\n"
            "%s_proxy_get_property (xobject_t      *object" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(
                " G_GNUC_UNUSED,\n"
                "  xuint_t         prop_id G_GNUC_UNUSED,\n"
                "  xvalue_t       *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                ",\n" "  xuint_t         prop_id,\n" "  xvalue_t       *value,\n"
            )
        self.outfile.write("  xparam_spec_t   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  xvariant_t *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = xdbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);\n"
                "  if (info->use_gvariant)\n"
                "    {\n"
                "      xvalue_set_variant (value, variant);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                # could be that we don't have the value in cache - in that case, we do
                # nothing and the user gets the default value for the xtype_t
                "      if (variant != NULL)\n"
                "        g_dbus_gvariant_to_gvalue (variant, value);\n"
                "    }\n"
                "  if (variant != NULL)\n"
                "    xvariant_unref (variant);\n" % (len(i.properties), i.name_lower)
            )
        self.outfile.write("}\n" "\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_proxy_set_property_cb (xdbus_proxy_t *proxy,\n"
                "  xasync_result_t *res,\n"
                "  xpointer_t      user_data)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info = user_data;\n"
                "  xerror_t *error;\n"
                "  xvariant_t *_ret;\n"
                "  error = NULL;\n"
                "  _ret = xdbus_proxy_call_finish (proxy, res, &error);\n"
                "  if (!_ret)\n"
                "    {\n"
                "      g_warning (\"Error setting property '%%s' on interface %s: %%s (%%s, %%d)\",\n"
                "                 info->parent_struct.name, \n"
                "                 error->message, g_quark_to_string (error->domain), error->code);\n"
                "      xerror_free (error);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      xvariant_unref (_ret);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write("}\n" "\n")
        self.outfile.write("static void\n" "%s_proxy_set_property (" % (i.name_lower))
        if len(i.properties) == 0:
            self.outfile.write(
                "xobject_t      *object G_GNUC_UNUSED,\n"
                "  xuint_t         prop_id G_GNUC_UNUSED,\n"
                "  const xvalue_t *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                "xobject_t      *object,\n"
                "  xuint_t         prop_id,\n"
                "  const xvalue_t *value,\n"
            )
        self.outfile.write("  xparam_spec_t   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  xvariant_t *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
                "  xdbus_proxy_call (G_DBUS_PROXY (object),\n"
                '    "org.freedesktop.DBus.Properties.Set",\n'
                '    xvariant_new ("(ssv)", "%s", info->parent_struct.name, variant),\n'
                "    G_DBUS_CALL_FLAGS_NONE,\n"
                "    -1,\n"
                "    NULL, (xasync_ready_callback_t) %s_proxy_set_property_cb, (xdbus_property_info_t *) &info->parent_struct);\n"
                "  xvariant_unref (variant);\n"
                % (len(i.properties), i.name_lower, i.name, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # signal received
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_signal (xdbus_proxy_t *proxy,\n"
            "  const xchar_t *sender_name G_GNUC_UNUSED,\n"
            "  const xchar_t *signal_name,\n"
            "  xvariant_t *parameters)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  _ExtendedGDBusSignalInfo *info;\n"
            "  xvariant_iter_t iter;\n"
            "  xvariant_t *child;\n"
            "  xvalue_t *paramv;\n"
            "  xsize_t num_params;\n"
            "  xsize_t n;\n"
            "  xuint_t signal_id;\n"
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((xdbus_interface_info_t *) &_%s_interface_info.parent_struct, signal_name);\n"
            "  if (info == NULL)\n"
            "    return;\n" % (i.name_lower)
        )
        self.outfile.write(
            "  num_params = xvariant_n_children (parameters);\n"
            "  paramv = g_new0 (xvalue_t, num_params + 1);\n"
            "  xvalue_init (&paramv[0], %sTYPE_%s);\n"
            "  xvalue_set_object (&paramv[0], proxy);\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  xvariant_iter_init (&iter, parameters);\n"
            "  n = 1;\n"
            "  while ((child = xvariant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          xvalue_init (&paramv[n], XTYPE_VARIANT);\n"
            "          xvalue_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      xvariant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = xsignal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write("  xsignal_emitv (paramv, signal_id, 0, NULL);\n")
        self.outfile.write(
            "  for (n = 0; n < num_params + 1; n++)\n"
            "    xvalue_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        # property changed
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_properties_changed (xdbus_proxy_t *_proxy,\n"
            "  xvariant_t *changed_properties,\n"
            "  const xchar_t *const *invalidated_properties)\n"
            "{\n" % (i.name_lower)
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (_proxy);\n"
            "  xuint_t n;\n"
            "  const xchar_t *key;\n"
            "  xvariant_iter_t *iter;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            '  xvariant_get (changed_properties, "a{sv}", &iter);\n'
            '  while (xvariant_iter_next (iter, "{&sv}", &key, NULL))\n'
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((xdbus_interface_info_t *) &_%s_interface_info.parent_struct, key);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, key);\n"
            "      if (info != NULL)\n"
            "        xobject_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "  xvariant_iter_free (iter);\n"
            "  for (n = 0; invalidated_properties[n] != NULL; n++)\n"
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((xdbus_interface_info_t *) &_%s_interface_info.parent_struct, invalidated_properties[n]);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);\n"
            "      if (info != NULL)\n"
            "        xobject_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "}\n"
            "\n" % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower, i.name_lower)
        )

        # property vfuncs
        for p in i.properties:
            nul_value = "0"
            if p.arg.free_func is not None:
                nul_value = "NULL"
            self.outfile.write(
                "static %s\n"
                "%s_proxy_get_%s (%s *object)\n"
                "{\n"
                "  %sProxy *proxy = %s%s_PROXY (object);\n"
                "  xvariant_t *variant;\n"
                "  %svalue = %s;\n"
                % (
                    p.arg.ctype_in,
                    i.name_lower,
                    p.name_lower,
                    i.camel_name,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    p.arg.ctype_in,
                    nul_value,
                )
            )
            # For some property types, we have to free the returned
            # value (or part of it, e.g. the container) because of how
            # xvariant_t works.. see https://bugzilla.gnome.org/show_bug.cgi?id=657100
            # for details
            #
            free_container = False
            if (
                p.arg.gvariant_get == "xvariant_get_strv"
                or p.arg.gvariant_get == "xvariant_get_objv"
                or p.arg.gvariant_get == "xvariant_get_bytestring_array"
            ):
                free_container = True
            # If already using an old value for strv, objv, bytestring_array (see below),
            # then just return that... that way the result from multiple consecutive calls
            # to the getter are valid as long as they're freed
            #
            if free_container:
                self.outfile.write(
                    '  value = g_datalist_get_data (&proxy->priv->qdata, "%s");\n'
                    "  if (value != NULL)\n"
                    "    return value;\n" % (p.name)
                )
            self.outfile.write(
                '  variant = xdbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "%s");\n'
                % (p.name)
            )
            if p.arg.gtype == "XTYPE_VARIANT":
                self.outfile.write("  value = variant;\n")
                self.outfile.write("  if (variant != NULL)\n")
                self.outfile.write("    xvariant_unref (variant);\n")
            else:
                self.outfile.write("  if (variant != NULL)\n" "    {\n")
                extra_len = ""
                if (
                    p.arg.gvariant_get == "xvariant_get_string"
                    or p.arg.gvariant_get == "xvariant_get_strv"
                    or p.arg.gvariant_get == "xvariant_get_objv"
                    or p.arg.gvariant_get == "xvariant_get_bytestring_array"
                ):
                    extra_len = ", NULL"
                self.outfile.write(
                    "      value = %s (variant%s);\n" % (p.arg.gvariant_get, extra_len)
                )
                if free_container:
                    self.outfile.write(
                        '      g_datalist_set_data_full (&proxy->priv->qdata, "%s", (xpointer_t) value, g_free);\n'
                        % (p.name)
                    )
                self.outfile.write("      xvariant_unref (variant);\n")
                self.outfile.write("    }\n")
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%s_proxy_init (%sProxy *proxy)\n"
            "{\n"
            "#if XPL_VERSION_MAX_ALLOWED >= XPL_VERSION_2_38\n"
            "  proxy->priv = %s_proxy_get_instance_private (proxy);\n"
            "#else\n"
            "  proxy->priv = XTYPE_INSTANCE_GET_PRIVATE (proxy, %sTYPE_%s_PROXY, %sProxyPrivate);\n"
            "#endif\n\n"
            "  xdbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), %s_interface_info ());\n"
            "}\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
                i.name_lower,
            )
        )
        self.outfile.write(
            "static void\n"
            "%s_proxy_class_init (%sProxyClass *klass)\n"
            "{\n"
            "  xobject_class_t *gobject_class;\n"
            "  GDBusProxyClass *proxy_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize     = %s_proxy_finalize;\n"
            "  gobject_class->get_property = %s_proxy_get_property;\n"
            "  gobject_class->set_property = %s_proxy_set_property;\n"
            "\n"
            "  proxy_class = G_DBUS_PROXY_CLASS (klass);\n"
            "  proxy_class->g_signal = %s_proxy_g_signal;\n"
            "  proxy_class->g_properties_changed = %s_proxy_g_properties_changed;\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
            )
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  %s_override_properties (gobject_class, 1);\n\n" % (i.name_lower)
            )
        self.outfile.write(
            "#if XPL_VERSION_MAX_ALLOWED < XPL_VERSION_2_38\n"
            "  xtype_class_add_private (klass, sizeof (%sProxyPrivate));\n"
            "#endif\n" % (i.camel_name)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_proxy_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_proxy_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new:\n"
                " * @connection: A #xdbus_connection_t.\n"
                " * @flags: Flags from the #xdbus_proxy_flags_t enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @callback: A #xasync_ready_callback_t to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates a proxy for the D-Bus interface #%s. See xdbus_proxy_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see xmain_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new (\n"
            "    xdbus_connection_t     *connection,\n"
            "    xdbus_proxy_flags_t      flags,\n"
            "    const xchar_t         *name,\n"
            "    const xchar_t         *object_path,\n"
            "    xcancellable_t        *cancellable,\n"
            "    xasync_ready_callback_t  callback,\n"
            "    xpointer_t             user_data)\n"
            "{\n"
            '  xasync_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_finish:\n"
            " * @res: The #xasync_result_t obtained from the #xasync_ready_callback_t passed to %s_proxy_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_finish (\n"
            "    xasync_result_t        *res,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xobject_t *ret;\n"
            "  xobject_t *source_object;\n"
            "  source_object = xasync_result_get_source_object (res);\n"
            "  ret = xasync_initable_new_finish (XASYNC_INITABLE (source_object), res, error);\n"
            "  xobject_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_sync:\n"
                " * @connection: A #xdbus_connection_t.\n"
                " * @flags: Flags from the #xdbus_proxy_flags_t enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates a proxy for the D-Bus interface #%s. See xdbus_proxy_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_sync (\n"
            "    xdbus_connection_t     *connection,\n"
            "    xdbus_proxy_flags_t      flags,\n"
            "    const xchar_t         *name,\n"
            "    const xchar_t         *object_path,\n"
            "    xcancellable_t        *cancellable,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xinitable_t *ret;\n"
            '  ret = xinitable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus:\n"
                " * @bus_type: A #xbus_type_t.\n"
                " * @flags: Flags from the #xdbus_proxy_flags_t enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @callback: A #xasync_ready_callback_t to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %s_proxy_new() but takes a #xbus_type_t instead of a #xdbus_connection_t.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see xmain_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new_for_bus (\n"
            "    xbus_type_t             bus_type,\n"
            "    xdbus_proxy_flags_t      flags,\n"
            "    const xchar_t         *name,\n"
            "    const xchar_t         *object_path,\n"
            "    xcancellable_t        *cancellable,\n"
            "    xasync_ready_callback_t  callback,\n"
            "    xpointer_t             user_data)\n"
            "{\n"
            '  xasync_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_for_bus_finish:\n"
            " * @res: The #xasync_result_t obtained from the #xasync_ready_callback_t passed to %s_proxy_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_finish (\n"
            "    xasync_result_t        *res,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xobject_t *ret;\n"
            "  xobject_t *source_object;\n"
            "  source_object = xasync_result_get_source_object (res);\n"
            "  ret = xasync_initable_new_finish (XASYNC_INITABLE (source_object), res, error);\n"
            "  xobject_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus_sync:\n"
                " * @bus_type: A #xbus_type_t.\n"
                " * @flags: Flags from the #xdbus_proxy_flags_t enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %s_proxy_new_sync() but takes a #xbus_type_t instead of a #xdbus_connection_t.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_sync (\n"
            "    xbus_type_t             bus_type,\n"
            "    xdbus_proxy_flags_t      flags,\n"
            "    const xchar_t         *name,\n"
            "    const xchar_t         *object_path,\n"
            "    xcancellable_t        *cancellable,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xinitable_t *ret;\n"
            '  ret = xinitable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_skeleton(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeleton:\n"
                " *\n"
                " * The #%sSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sSkeleton.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sSkeletonPrivate\n"
            "{\n"
            "  xvalue_t *properties;\n"
            "  xlist_t *changed_properties;\n"
            "  xsource_t *changed_properties_idle_source;\n"
            "  xmain_context_t *context;\n"
            "  xmutex_t lock;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void\n"
            "_%s_skeleton_handle_method_call (\n"
            "  xdbus_connection_t *connection G_GNUC_UNUSED,\n"
            "  const xchar_t *sender G_GNUC_UNUSED,\n"
            "  const xchar_t *object_path G_GNUC_UNUSED,\n"
            "  const xchar_t *interface_name,\n"
            "  const xchar_t *method_name,\n"
            "  xvariant_t *parameters,\n"
            "  xdbus_method_invocation_t *invocation,\n"
            "  xpointer_t user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  _ExtendedGDBusMethodInfo *info;\n"
            "  xvariant_iter_t iter;\n"
            "  xvariant_t *child;\n"
            "  xvalue_t *paramv;\n"
            "  xsize_t num_params;\n"
            "  xuint_t num_extra;\n"
            "  xsize_t n;\n"
            "  xuint_t signal_id;\n"
            "  xvalue_t return_value = G_VALUE_INIT;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  info = (_ExtendedGDBusMethodInfo *) xdbus_method_invocation_get_method_info (invocation);\n"
            "  g_assert (info != NULL);\n"
        )
        self.outfile.write(
            "  num_params = xvariant_n_children (parameters);\n"
            "  num_extra = info->pass_fdlist ? 3 : 2;"
            "  paramv = g_new0 (xvalue_t, num_params + num_extra);\n"
            "  n = 0;\n"
            "  xvalue_init (&paramv[n], %sTYPE_%s);\n"
            "  xvalue_set_object (&paramv[n++], skeleton);\n"
            "  xvalue_init (&paramv[n], XTYPE_DBUS_METHOD_INVOCATION);\n"
            "  xvalue_set_object (&paramv[n++], invocation);\n"
            "  if (info->pass_fdlist)\n"
            "    {\n"
            "#ifdef G_OS_UNIX\n"
            "      xvalue_init (&paramv[n], XTYPE_UNIX_FD_LIST);\n"
            "      xvalue_set_object (&paramv[n++], xdbus_message_get_unix_fd_list (xdbus_method_invocation_get_message (invocation)));\n"
            "#else\n"
            "      g_assert_not_reached ();\n"
            "#endif\n"
            "    }\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  xvariant_iter_init (&iter, parameters);\n"
            "  while ((child = xvariant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          xvalue_init (&paramv[n], XTYPE_VARIANT);\n"
            "          xvalue_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      xvariant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = xsignal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  xvalue_init (&return_value, XTYPE_BOOLEAN);\n"
            "  xsignal_emitv (paramv, signal_id, 0, &return_value);\n"
            "  if (!xvalue_get_boolean (&return_value))\n"
            '    xdbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);\n'
            "  xvalue_unset (&return_value);\n"
        )
        self.outfile.write(
            "  for (n = 0; n < num_params + num_extra; n++)\n"
            "    xvalue_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static xvariant_t *\n"
            "_%s_skeleton_handle_get_property (\n"
            "  xdbus_connection_t *connection G_GNUC_UNUSED,\n"
            "  const xchar_t *sender G_GNUC_UNUSED,\n"
            "  const xchar_t *object_path G_GNUC_UNUSED,\n"
            "  const xchar_t *interface_name G_GNUC_UNUSED,\n"
            "  const xchar_t *property_name,\n"
            "  xerror_t **error,\n"
            "  xpointer_t user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  xvalue_t value = G_VALUE_INIT;\n"
            "  xparam_spec_t *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  xvariant_t *ret;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = NULL;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((xdbus_interface_info_t *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = xobject_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      xvalue_init (&value, pspec->value_type);\n"
            "      xobject_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
            "      xvalue_unset (&value);\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static xboolean_t\n"
            "_%s_skeleton_handle_set_property (\n"
            "  xdbus_connection_t *connection G_GNUC_UNUSED,\n"
            "  const xchar_t *sender G_GNUC_UNUSED,\n"
            "  const xchar_t *object_path G_GNUC_UNUSED,\n"
            "  const xchar_t *interface_name G_GNUC_UNUSED,\n"
            "  const xchar_t *property_name,\n"
            "  xvariant_t *variant,\n"
            "  xerror_t **error,\n"
            "  xpointer_t user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  xvalue_t value = G_VALUE_INIT;\n"
            "  xparam_spec_t *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  xboolean_t ret;\n" % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = FALSE;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((xdbus_interface_info_t *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = xobject_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      if (info->use_gvariant)\n"
            "        xvalue_set_variant (&value, variant);\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (variant, &value);\n"
            "      xobject_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      xvalue_unset (&value);\n"
            "      ret = TRUE;\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static const xdbus_interface_vtable_t _%s_skeleton_vtable =\n"
            "{\n"
            "  _%s_skeleton_handle_method_call,\n"
            "  _%s_skeleton_handle_get_property,\n"
            "  _%s_skeleton_handle_set_property,\n"
            "  {NULL}\n"
            "};\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower)
        )

        self.outfile.write(
            "static xdbus_interface_info_t *\n"
            "%s_skeleton_dbus_interface_get_info (xdbus_interface_skeleton_t *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return %s_interface_info ();\n" % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static xdbus_interface_vtable_t *\n"
            "%s_skeleton_dbus_interface_get_vtable (xdbus_interface_skeleton_t *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return (xdbus_interface_vtable_t *) &_%s_skeleton_vtable;\n"
            % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static xvariant_t *\n"
            "%s_skeleton_dbus_interface_get_properties (xdbus_interface_skeleton_t *_skeleton)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "\n"
            "  xvariant_builder_t builder;\n"
            "  xuint_t n;\n"
            '  xvariant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
            "  if (_%s_interface_info.parent_struct.properties == NULL)\n"
            "    goto out;\n"
            "  for (n = 0; _%s_interface_info.parent_struct.properties[n] != NULL; n++)\n"
            "    {\n"
            "      xdbus_property_info_t *info = _%s_interface_info.parent_struct.properties[n];\n"
            "      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n"
            "        {\n"
            "          xvariant_t *value;\n"
            '          value = _%s_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", info->name, NULL, skeleton);\n'
            "          if (value != NULL)\n"
            "            {\n"
            "              xvariant_take_ref (value);\n"
            '              xvariant_builder_add (&builder, "{sv}", info->name, value);\n'
            "              xvariant_unref (value);\n"
            "            }\n"
            "        }\n"
            "    }\n"
            "out:\n"
            "  return xvariant_builder_end (&builder);\n"
            "}\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower, i.name)
        )

        if len(i.properties) > 0:
            self.outfile.write(
                "static xboolean_t _%s_emit_changed (xpointer_t user_data);\n"
                "\n" % (i.name_lower)
            )

        self.outfile.write(
            "static void\n"
            "%s_skeleton_dbus_interface_flush (xdbus_interface_skeleton_t *_skeleton"
            % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
                "  xboolean_t emit_changed = FALSE;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
                "    {\n"
                "      xsource_destroy (skeleton->priv->changed_properties_idle_source);\n"
                "      skeleton->priv->changed_properties_idle_source = NULL;\n"
                "      emit_changed = TRUE;\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "\n"
                "  if (emit_changed)\n"
                "    _%s_emit_changed (skeleton);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        for s in i.signals:
            self.outfile.write(
                "static void\n"
                "_%s_on_signal_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n\n"
                "  xlist_t      *connections, *l;\n"
                "  xvariant_t   *signal_variant;\n"
                "  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "\n" '  signal_variant = xvariant_ref_sink (xvariant_new ("('
            )
            for a in s.args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in s.args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("));\n")

            self.outfile.write(
                "  for (l = connections; l != NULL; l = l->next)\n"
                "    {\n"
                "      xdbus_connection_t *connection = l->data;\n"
                "      xdbus_connection_emit_signal (connection,\n"
                '        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", "%s",\n'
                "        signal_variant, NULL);\n"
                "    }\n" % (i.name, s.name)
            )
            self.outfile.write("  xvariant_unref (signal_variant);\n")
            self.outfile.write("  xlist_free_full (connections, xobject_unref);\n")
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void %s_skeleton_iface_init (%sIface *iface);\n"
            % (i.name_lower, i.camel_name)
        )

        self.outfile.write("#if XPL_VERSION_MAX_ALLOWED >= XPL_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, XTYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sSkeleton)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, XTYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_skeleton_finalize (xobject_t *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  xuint_t n;\n"
                "  for (n = 0; n < %d; n++)\n"
                "    xvalue_unset (&skeleton->priv->properties[n]);\n"
                % (len(i.properties))
            )
            self.outfile.write("  g_free (skeleton->priv->properties);\n")
        self.outfile.write(
            "  xlist_free_full (skeleton->priv->changed_properties, (xdestroy_notify_t) _changed_property_free);\n"
        )
        self.outfile.write(
            "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
        )
        self.outfile.write(
            "    xsource_destroy (skeleton->priv->changed_properties_idle_source);\n"
        )
        self.outfile.write("  xmain_context_unref (skeleton->priv->context);\n")
        self.outfile.write("  g_mutex_clear (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_skeleton_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors (TODO: generate PropertiesChanged signals in setter)
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_skeleton_get_property (xobject_t      *object,\n"
                "  xuint_t         prop_id,\n"
                "  xvalue_t       *value,\n"
                "  xparam_spec_t   *pspec G_GNUC_UNUSED)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  xvalue_copy (&skeleton->priv->properties[prop_id - 1], value);\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, len(i.properties))
            )
            self.outfile.write("}\n" "\n")

            # if property is already scheduled then re-use entry.. though it could be
            # that the user did
            #
            #  foo_set_prop_bar (object, "");
            #  foo_set_prop_bar (object, "blah");
            #
            # say, every update... In this case, where nothing happens, we obviously
            # don't want a PropertiesChanged() event. We can easily check for this
            # by comparing against the _original value_ recorded before the first
            # change event. If the latest value is not different from the original
            # one, we can simply ignore the ChangedProperty
            #
            self.outfile.write(
                "static xboolean_t\n"
                "_%s_emit_changed (xpointer_t user_data)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
                % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  xlist_t *l;\n"
                "  xvariant_builder_t builder;\n"
                "  xvariant_builder_t invalidated_builder;\n"
                "  xuint_t num_changes;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                '  xvariant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                '  xvariant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));\n'
                "  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *cp = l->data;\n"
                "      xvariant_t *variant;\n"
                "      const xvalue_t *cur_value;\n"
                "\n"
                "      cur_value = &skeleton->priv->properties[cp->prop_id - 1];\n"
                "      if (!_xvalue_equal (cur_value, &cp->orixvalue))\n"
                "        {\n"
                "          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));\n"
                '          xvariant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);\n'
                "          xvariant_unref (variant);\n"
                "          num_changes++;\n"
                "        }\n"
                "    }\n"
                "  if (num_changes > 0)\n"
                "    {\n"
                "      xlist_t *connections, *ll;\n"
                "      xvariant_t *signal_variant;"
                "\n"
                '      signal_variant = xvariant_ref_sink (xvariant_new ("(sa{sv}as)", "%s",\n'
                "                                           &builder, &invalidated_builder));\n"
                "      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                "      for (ll = connections; ll != NULL; ll = ll->next)\n"
                "        {\n"
                "          xdbus_connection_t *connection = ll->data;\n"
                "\n"
                "          xdbus_connection_emit_signal (connection,\n"
                "                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),\n"
                '                                         "org.freedesktop.DBus.Properties",\n'
                '                                         "PropertiesChanged",\n'
                "                                         signal_variant,\n"
                "                                         NULL);\n"
                "        }\n"
                "      xvariant_unref (signal_variant);\n"
                "      xlist_free_full (connections, xobject_unref);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      xvariant_builder_clear (&builder);\n"
                "      xvariant_builder_clear (&invalidated_builder);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write(
                "  xlist_free_full (skeleton->priv->changed_properties, (xdestroy_notify_t) _changed_property_free);\n"
            )
            self.outfile.write("  skeleton->priv->changed_properties = NULL;\n")
            self.outfile.write(
                "  skeleton->priv->changed_properties_idle_source = NULL;\n"
            )
            self.outfile.write("  g_mutex_unlock (&skeleton->priv->lock);\n")
            self.outfile.write("  return FALSE;\n" "}\n" "\n")
            # holding lock while being called
            self.outfile.write(
                "static void\n"
                "_%s_schedule_emit_changed (%sSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, xuint_t prop_id, const xvalue_t *orixvalue)\n"
                "{\n"
                "  ChangedProperty *cp;\n"
                "  xlist_t *l;\n"
                "  cp = NULL;\n"
                "  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *i_cp = l->data;\n"
                "      if (i_cp->info == info)\n"
                "        {\n"
                "          cp = i_cp;\n"
                "          break;\n"
                "        }\n"
                "    }\n" % (i.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  if (cp == NULL)\n"
                "    {\n"
                "      cp = g_new0 (ChangedProperty, 1);\n"
                "      cp->prop_id = prop_id;\n"
                "      cp->info = info;\n"
                "      skeleton->priv->changed_properties = xlist_prepend (skeleton->priv->changed_properties, cp);\n"
                "      xvalue_init (&cp->orixvalue, G_VALUE_TYPE (orixvalue));\n"
                "      xvalue_copy (orixvalue, &cp->orixvalue);\n"
                "    }\n"
                "}\n"
                "\n"
            )

            # Postpone setting up the refresh source until the ::notify signal is emitted as
            # this allows use of xobject_freeze_notify()/xobject_thaw_notify() ...
            # This is useful when updating several properties from another thread than
            # where the idle will be emitted from
            self.outfile.write(
                "static void\n"
                "%s_skeleton_notify (xobject_t      *object,\n"
                "  xparam_spec_t *pspec G_GNUC_UNUSED)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties != NULL &&\n"
                "      skeleton->priv->changed_properties_idle_source == NULL)\n"
                "    {\n"
                "      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();\n"
                "      xsource_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);\n"
                "      xsource_set_callback (skeleton->priv->changed_properties_idle_source, _%s_emit_changed, xobject_ref (skeleton), (xdestroy_notify_t) xobject_unref);\n"
                '      xsource_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _%s_emit_changed");\n'
                "      xsource_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);\n"
                "      xsource_unref (skeleton->priv->changed_properties_idle_source);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "}\n"
                "\n"
                % (
                    i.name_lower,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    i.name_lower,
                    i.name_lower,
                )
            )

            self.outfile.write(
                "static void\n"
                "%s_skeleton_set_property (xobject_t      *object,\n"
                "  xuint_t         prop_id,\n"
                "  const xvalue_t *value,\n"
                "  xparam_spec_t   *pspec)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  xobject_freeze_notify (object);\n"
                "  if (!_xvalue_equal (value, &skeleton->priv->properties[prop_id - 1]))\n"
                "    {\n"
                "      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&\n"
                "          info->emits_changed_signal)\n"
                "        _%s_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);\n"
                "      xvalue_copy (value, &skeleton->priv->properties[prop_id - 1]);\n"
                "      xobject_notify_by_pspec (object, pspec);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "  xobject_thaw_notify (object);\n"
                % (
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    len(i.properties),
                    i.name_lower,
                    i.name_lower,
                )
            )
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_init (%sSkeleton *skeleton)\n"
            "{\n"
            "#if XPL_VERSION_MAX_ALLOWED >= XPL_VERSION_2_38\n"
            "  skeleton->priv = %s_skeleton_get_instance_private (skeleton);\n"
            "#else\n"
            "  skeleton->priv = XTYPE_INSTANCE_GET_PRIVATE (skeleton, %sTYPE_%s_SKELETON, %sSkeletonPrivate);\n"
            "#endif\n\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
            )
        )
        self.outfile.write("  g_mutex_init (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  skeleton->priv->context = xmain_context_ref_thread_default ();\n"
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  skeleton->priv->properties = g_new0 (xvalue_t, %d);\n"
                % (len(i.properties))
            )
            n = 0
            for p in i.properties:
                self.outfile.write(
                    "  xvalue_init (&skeleton->priv->properties[%d], %s);\n"
                    % (n, p.arg.gtype)
                )
                n += 1
        self.outfile.write("}\n" "\n")

        # property vfuncs
        n = 0
        for p in i.properties:
            self.outfile.write(
                "static %s\n"
                "%s_skeleton_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  %svalue;\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  value = %s (&(skeleton->priv->properties[%d]));\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (p.arg.ctype_in_g, p.arg.gvalue_get, n)
            )
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")
            n += 1

        self.outfile.write(
            "static void\n"
            "%s_skeleton_class_init (%sSkeletonClass *klass)\n"
            "{\n"
            "  xobject_class_t *gobject_class;\n"
            "  GDBusInterfaceSkeletonClass *skeleton_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize = %s_skeleton_finalize;\n"
            % (i.name_lower, i.camel_name, i.name_lower)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  gobject_class->get_property = %s_skeleton_get_property;\n"
                "  gobject_class->set_property = %s_skeleton_set_property;\n"
                "  gobject_class->notify       = %s_skeleton_notify;\n"
                "\n" % (i.name_lower, i.name_lower, i.name_lower)
            )
            self.outfile.write(
                "\n" "  %s_override_properties (gobject_class, 1);\n" % (i.name_lower)
            )
        self.outfile.write(
            "\n" "  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);\n"
        )
        self.outfile.write(
            "  skeleton_class->get_info = %s_skeleton_dbus_interface_get_info;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_properties = %s_skeleton_dbus_interface_get_properties;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->flush = %s_skeleton_dbus_interface_flush;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_vtable = %s_skeleton_dbus_interface_get_vtable;\n"
            % (i.name_lower)
        )

        self.outfile.write(
            "\n"
            "#if XPL_VERSION_MAX_ALLOWED < XPL_VERSION_2_38\n"
            "  xtype_class_add_private (klass, sizeof (%sSkeletonPrivate));\n"
            "#endif\n" % (i.camel_name)
        )

        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for s in i.signals:
            self.outfile.write(
                "  iface->%s = _%s_on_signal_%s;\n"
                % (s.name_lower, i.name_lower, s.name_lower)
            )
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_skeleton_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_skeleton_new:\n"
                " *\n"
                " * Creates a skeleton object for the D-Bus interface #%s.\n"
                " *\n"
                " * Returns: (transfer full) (type %sSkeleton): The skeleton object.\n"
                % (i.name_lower, i.name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_skeleton_new (void)\n"
            "{\n"
            "  return %s%s (xobject_new (%sTYPE_%s_SKELETON, NULL));\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.ns_upper,
                i.name_upper,
            )
        )

    # ---------------------------------------------------------------------------------------------------

    def generate_object(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for Object, ObjectProxy and ObjectSkeleton\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObject\n"
                " * @title: %sObject\n"
                " * @short_description: Specialized xdbus_object_t types\n"
                " *\n"
                " * This section contains the #%sObject, #%sObjectProxy, and #%sObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.\n"
                " */\n"
                % (
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                ),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObject:\n"
                " *\n"
                " * The #%sObject type is a specialized container of interfaces.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectIface:\n"
                " * @parent_iface: The parent interface.\n"
                " *\n"
                " * Virtual table for the #%sObject interface.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sObjectIface %sObjectInterface;\n"
            % (self.namespace, self.namespace)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE_WITH_CODE (%sobject, %sobject, XTYPE_OBJECT, xtype_interface_add_prerequisite (g_define_type_id, XTYPE_DBUS_OBJECT);)\n"
            % (self.namespace, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_default_init (%sObjectIface *iface)\n"
            "{\n" % (self.ns_lower, self.namespace)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "  /**\n"
                    "   * %sObject:%s:\n"
                    "   *\n"
                    "   * The #%s instance corresponding to the D-Bus interface #%s, if any.\n"
                    "   *\n"
                    "   * Connect to the #xobject_t::notify signal to get informed of property changes.\n"
                    % (self.namespace, i.name_hyphen, i.camel_name, i.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 2)
            flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
            if i.deprecated:
                flags = "G_PARAM_DEPRECATED | " + flags
            self.outfile.write(
                '  xobject_interface_install_property (iface, g_param_spec_object ("%s", "%s", "%s", %sTYPE_%s, %s));\n'
                "\n"
                % (
                    i.name_hyphen,
                    i.name_hyphen,
                    i.name_hyphen,
                    self.ns_upper,
                    i.name_upper,
                    flags,
                )
            )
        self.outfile.write("}\n" "\n")

        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_get_%s:\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Gets the #%s instance for the D-Bus interface #%s on @object, if any.\n"
                    " *\n"
                    " * Returns: (transfer full) (nullable): A #%s that must be freed with xobject_unref() or %%NULL if @object does not implement the interface.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.name,
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_get_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  xdbus_interface_t *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_peek_%s: (skip)\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Like %sobject_get_%s() but doesn't increase the reference count on the returned object.\n"
                    " *\n"
                    " * It is not safe to use the returned object if you are on another thread than the one where the #xdbus_object_manager_client_t or #xdbus_object_manager_server_t for @object is running.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): A #%s or %%NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        self.ns_lower,
                        i.name_upper.lower(),
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_peek_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  xdbus_interface_t *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  xobject_unref (ret);\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        # shared by ObjectProxy and ObjectSkeleton classes
        self.outfile.write(
            "static void\n"
            "%sobject_notify (xdbus_object_t *object, xdbus_interface_t *interface)\n"
            "{\n"
            "  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);\n"
            "  /* info can be NULL if the other end is using a D-Bus interface we don't know\n"
            "   * anything about, for example old generated code in this process talking to\n"
            "   * newer generated code in the other process. */\n"
            "  if (info != NULL)\n"
            "    xobject_notify (G_OBJECT (object), info->hyphen_name);\n"
            "}\n"
            "\n" % (self.ns_lower)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxy:\n"
                " *\n"
                " * The #%sObjectProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectProxy.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__g_dbus_object_iface_init (xdbus_object_iface_t *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectProxy, %sobject_proxy, XTYPE_DBUS_OBJECT_PROXY,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_proxy__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (XTYPE_DBUS_OBJECT, %sobject_proxy__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_init (%sObjectProxy *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_set_property (xobject_t      *gobject,\n"
            "  xuint_t         prop_id,\n"
            "  const xvalue_t *value G_GNUC_UNUSED,\n"
            "  xparam_spec_t   *pspec)\n"
            "{\n"
            "  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            % (self.ns_lower)
        )
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_get_property (xobject_t      *gobject,\n"
            "  xuint_t         prop_id,\n"
            "  xvalue_t       *value,\n"
            "  xparam_spec_t   *pspec)\n"
            "{\n"
            "  %sObjectProxy *object = %sOBJECT_PROXY (gobject);\n"
            "  xdbus_interface_t *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      xvalue_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_class_init (%sObjectProxyClass *klass)\n"
            "{\n"
            "  xobject_class_t *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_proxy_set_property;\n"
            "  gobject_class->get_property = %sobject_proxy_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  xobject_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_proxy_new:\n"
                " * @connection: A #xdbus_connection_t.\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new proxy object.\n"
                " *\n"
                " * Returns: (transfer full): The proxy object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectProxy *\n"
            "%sobject_proxy_new (xdbus_connection_t *connection,\n"
            "  const xchar_t *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (X_IS_DBUS_CONNECTION (connection), NULL);\n"
            "  g_return_val_if_fail (xvariant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_PROXY (xobject_new (%sTYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeleton:\n"
                " *\n"
                " * The #%sObjectSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectSkeleton.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__g_dbus_object_iface_init (xdbus_object_iface_t *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectSkeleton, %sobject_skeleton, XTYPE_DBUS_OBJECT_SKELETON,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_skeleton__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (XTYPE_DBUS_OBJECT, %sobject_skeleton__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_init (%sObjectSkeleton *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_set_property (xobject_t      *gobject,\n"
            "  xuint_t         prop_id,\n"
            "  const xvalue_t *value,\n"
            "  xparam_spec_t   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  xdbus_interface_skeleton_t *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                "      interface = xvalue_get_object (value);\n"
                "      if (interface != NULL)\n"
                "        {\n"
                "          g_warn_if_fail (%sIS_%s (interface));\n"
                "          xdbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);\n"
                "        }\n"
                "      else\n"
                "        {\n"
                '          xdbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "%s");\n'
                "        }\n"
                "      break;\n"
                "\n" % (n, self.ns_upper, i.name_upper, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_get_property (xobject_t      *gobject,\n"
            "  xuint_t         prop_id,\n"
            "  xvalue_t       *value,\n"
            "  xparam_spec_t   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  xdbus_interface_t *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      xvalue_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_class_init (%sObjectSkeletonClass *klass)\n"
            "{\n"
            "  xobject_class_t *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_skeleton_set_property;\n"
            "  gobject_class->get_property = %sobject_skeleton_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  xobject_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_skeleton_new:\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new skeleton object.\n"
                " *\n"
                " * Returns: (transfer full): The skeleton object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectSkeleton *\n"
            "%sobject_skeleton_new (const xchar_t *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (xvariant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_SKELETON (xobject_new (%sTYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_skeleton_set_%s:\n"
                    " * @object: A #%sObjectSkeleton.\n"
                    " * @interface_: (nullable): A #%s or %%NULL to clear the interface.\n"
                    " *\n"
                    " * Sets the #%s instance for the D-Bus interface #%s on @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.camel_name,
                        i.name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "void %sobject_skeleton_set_%s (%sObjectSkeleton *object, %s *interface_)\n"
                % (self.ns_lower, i.name_upper.lower(), self.namespace, i.camel_name)
            )
            self.outfile.write(
                "{\n"
                '  xobject_set (G_OBJECT (object), "%s", interface_, NULL);\n'
                "}\n"
                "\n" % (i.name_hyphen)
            )
        self.outfile.write("\n")

    def generate_object_manager_client(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for ObjectManager client\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObjectManagerClient\n"
                " * @title: %sObjectManagerClient\n"
                " * @short_description: Generated xdbus_object_manager_client_t type\n"
                " *\n"
                " * This section contains a #xdbus_object_manager_client_t that uses %sobject_manager_client_get_proxy_type() as the #xdbus_proxy_type_func_t.\n"
                " */\n" % (self.namespace, self.namespace, self.ns_lower),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClient:\n"
                " *\n"
                " * The #%sObjectManagerClient structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClientClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectManagerClient.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "G_DEFINE_TYPE (%sObjectManagerClient, %sobject_manager_client, XTYPE_DBUS_OBJECT_MANAGER_CLIENT)\n"
            "\n" % (self.namespace, self.ns_lower)
        )

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_init (%sObjectManagerClient *manager G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_class_init (%sObjectManagerClientClass *klass G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_get_proxy_type:\n"
                " * @manager: A #xdbus_object_manager_client_t.\n"
                " * @object_path: The object path of the remote object (unused).\n"
                " * @interface_name: (nullable): Interface name of the remote object or %%NULL to get the object proxy #xtype_t.\n"
                " * @user_data: User data (unused).\n"
                " *\n"
                " * A #xdbus_proxy_type_func_t that maps @interface_name to the generated #xdbus_object_proxy_t derived and #xdbus_proxy_t derived types.\n"
                " *\n"
                " * Returns: A #xdbus_proxy_t derived #xtype_t if @interface_name is not %%NULL, otherwise the #xtype_t for #%sObjectProxy.\n"
                % (self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "xtype_t\n"
            "%sobject_manager_client_get_proxy_type (xdbus_object_manager_client_t *manager G_GNUC_UNUSED, const xchar_t *object_path G_GNUC_UNUSED, const xchar_t *interface_name, xpointer_t user_data G_GNUC_UNUSED)\n"
            "{\n" % (self.ns_lower)
        )
        self.outfile.write(
            "  static xsize_t once_init_value = 0;\n"
            "  static xhashtable_t *lookup_hash;\n"
            "  xtype_t ret;\n"
            "\n"
            "  if (interface_name == NULL)\n"
            "    return %sTYPE_OBJECT_PROXY;\n"
            "  if (g_once_init_enter (&once_init_value))\n"
            "    {\n"
            "      lookup_hash = xhash_table_new (xstr_hash, xstr_equal);\n"
            % (self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                '      xhash_table_insert (lookup_hash, (xpointer_t) "%s", GSIZE_TO_POINTER (%sTYPE_%s_PROXY));\n'
                % (i.name, i.ns_upper, i.name_upper)
            )
        self.outfile.write("      g_once_init_leave (&once_init_value, 1);\n" "    }\n")
        self.outfile.write(
            "  ret = (xtype_t) GPOINTER_TO_SIZE (xhash_table_lookup (lookup_hash, interface_name));\n"
            "  if (ret == (xtype_t) 0)\n"
            "    ret = XTYPE_DBUS_PROXY;\n"
        )
        self.outfile.write("  return ret;\n" "}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new:\n"
                " * @connection: A #xdbus_connection_t.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @callback: A #xasync_ready_callback_t to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates #xdbus_object_manager_client_t using %sobject_manager_client_get_proxy_type() as the #xdbus_proxy_type_func_t. See xdbus_object_manager_client_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see xmain_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new (\n"
            "    xdbus_connection_t        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const xchar_t            *name,\n"
            "    const xchar_t            *object_path,\n"
            "    xcancellable_t           *cancellable,\n"
            "    xasync_ready_callback_t     callback,\n"
            "    xpointer_t                user_data)\n"
            "{\n"
            '  xasync_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_finish:\n"
            " * @res: The #xasync_result_t obtained from the #xasync_ready_callback_t passed to %sobject_manager_client_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "xdbus_object_manager_t *\n"
            "%sobject_manager_client_new_finish (\n"
            "    xasync_result_t        *res,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xobject_t *ret;\n"
            "  xobject_t *source_object;\n"
            "  source_object = xasync_result_get_source_object (res);\n"
            "  ret = xasync_initable_new_finish (XASYNC_INITABLE (source_object), res, error);\n"
            "  xobject_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_sync:\n"
                " * @connection: A #xdbus_connection_t.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates #xdbus_object_manager_client_t using %sobject_manager_client_get_proxy_type() as the #xdbus_proxy_type_func_t. See xdbus_object_manager_client_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "xdbus_object_manager_t *\n"
            "%sobject_manager_client_new_sync (\n"
            "    xdbus_connection_t        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const xchar_t            *name,\n"
            "    const xchar_t            *object_path,\n"
            "    xcancellable_t           *cancellable,\n"
            "    xerror_t                **error)\n"
            "{\n"
            "  xinitable_t *ret;\n"
            '  ret = xinitable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus:\n"
                " * @bus_type: A #xbus_type_t.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @callback: A #xasync_ready_callback_t to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %sobject_manager_client_new() but takes a #xbus_type_t instead of a #xdbus_connection_t.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see xmain_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new_for_bus (\n"
            "    xbus_type_t                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const xchar_t            *name,\n"
            "    const xchar_t            *object_path,\n"
            "    xcancellable_t           *cancellable,\n"
            "    xasync_ready_callback_t     callback,\n"
            "    xpointer_t                user_data)\n"
            "{\n"
            '  xasync_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_for_bus_finish:\n"
            " * @res: The #xasync_result_t obtained from the #xasync_ready_callback_t passed to %sobject_manager_client_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "xdbus_object_manager_t *\n"
            "%sobject_manager_client_new_for_bus_finish (\n"
            "    xasync_result_t        *res,\n"
            "    xerror_t             **error)\n"
            "{\n"
            "  xobject_t *ret;\n"
            "  xobject_t *source_object;\n"
            "  source_object = xasync_result_get_source_object (res);\n"
            "  ret = xasync_initable_new_finish (XASYNC_INITABLE (source_object), res, error);\n"
            "  xobject_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus_sync:\n"
                " * @bus_type: A #xbus_type_t.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #xcancellable_t or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %sobject_manager_client_new_sync() but takes a #xbus_type_t instead of a #xdbus_connection_t.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "xdbus_object_manager_t *\n"
            "%sobject_manager_client_new_for_bus_sync (\n"
            "    xbus_type_t                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const xchar_t            *name,\n"
            "    const xchar_t            *object_path,\n"
            "    xcancellable_t           *cancellable,\n"
            "    xerror_t                **error)\n"
            "{\n"
            "  xinitable_t *ret;\n"
            '  ret = xinitable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def write_gtkdoc_deprecated_and_since_and_close(self, obj, f, indent):
        if len(obj.since) > 0:
            f.write("%*s *\n" "%*s * Since: %s\n" % (indent, "", indent, "", obj.since))
        if obj.deprecated:
            if isinstance(obj, dbustypes.Interface):
                thing = "The D-Bus interface"
            elif isinstance(obj, dbustypes.Method):
                thing = "The D-Bus method"
            elif isinstance(obj, dbustypes.Signal):
                thing = "The D-Bus signal"
            elif isinstance(obj, dbustypes.Property):
                thing = "The D-Bus property"
            else:
                print_error('Cannot handle object "{}"'.format(obj))
            f.write(
                self.docbook_gen.expand(
                    "%*s *\n"
                    "%*s * Deprecated: %s has been deprecated.\n"
                    % (indent, "", indent, "", thing),
                    False,
                )
            )
        f.write("%*s */\n" % (indent, ""))

    # ---------------------------------------------------------------------------------------------------

    def generate_interface_intro(self, i):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for interface %s\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n" % (i.name)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%s\n"
                " * @title: %s\n"
                " * @short_description: Generated C code for the %s D-Bus interface\n"
                " *\n"
                " * This section contains code for working with the #%s D-Bus interface in C.\n"
                " */\n" % (i.camel_name, i.camel_name, i.name, i.name),
                False,
            )
        )
        self.outfile.write("\n")

    def generate(self):
        self.generate_body_preamble()
        for i in self.ifaces:
            self.generate_interface_intro(i)
            self.generate_introspection_for_interface(i)
            self.generate_interface(i)
            self.generate_property_accessors(i)
            self.generate_signal_emitters(i)
            self.generate_method_calls(i)
            self.generate_method_completers(i)
            self.generate_proxy(i)
            self.generate_skeleton(i)
        if self.generate_objmanager:
            self.generate_object()
            self.generate_object_manager_client()
